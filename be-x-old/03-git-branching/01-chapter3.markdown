# Галінаваньне ў Git #

Амаль кожная СКВ у разнастайнай форме падтрымлівае галінаваньне. Галінаваньне азначае, што вы адхіляецеся ад асноўнага шляху разпрацоўкі і працягваеце працаваць, не кранаючы асноўную лінію. Для шматлікіх СКВ гэта вельмі дарагі працэс, і часта патрабует ад вас стварэньня новай копіі каталёга з зыходнікамі, што можа запатрабаваць шмат часу для вялікіх праектаў.

Хтосьці кажа, што мадэль галінаваньня ў Git гэта яго “крутая штука“ і яна безумоўна зьяўляецца перавагай для Git у асяродзьдзі СКВ. Што ж у ёй такаго асаблівага? Спосаб галінаваньня ў Git вельмі лёгкаважкі, і гэта робіць апэрацыі галінаваньня імгненнымі, а пераключэньне туды-сюды паміж галінамі адбываецца таксама хутка. У адрозьненьні ад шматлікіх іншых СКВ, Git заахвочвае такі працэс, пры якім галінаваньне і зьліцьцё адбываюцца часта, нават па некалькі разоў на дзень. Разуменьне і выкарыстаньне гэтай функцыйнасьці дае вам унікальную прыладу і можа літаральна зьмяніць тое, як вы ажыцьцяўляеце разпрацоўку.

## Што такое галіна ##

Каб насамрэч зразумець як працуе Git з галінамі, мы павінны зрабіць крок назад і разгледзіць, як Git захоўвае свае даньні. Як вы напэўна памятаеце з *Главы 1*, Git не захоўвае даньні як пасьлядоўнасьць зьменаў ці дэльт(розьніцаў), а як пасьлядоўнасьць здамкаў стану(snapshot). 

Калі вы фіксуеце зьмены ў Git, Git захоўвае аб'ект, які утрымлівае паказвальнік на здымак зьместа індэкса, метаданьні аўтра і каментары і нуль ці больш паказальнікаў на каміты, якія былі прамымі продкамі гэтага каміта: нуль продкаў для першага каміта, адзін - для звычайнага каміта і некалькі - для каміта, атрыманага ў выніку зьліцьця дзьвух ці больш галінаў.

Для нагляднасьці, давайце ўявім, што у вас ёсьць каталёг, у якім знаходзяцца тры файлы, і вы іх ўсе індэксуеце і робіце каміт. Пры падрыхтоўцы файлаў для кожнага зь іх вылічваецца кантрольная сума (SHA-1 хэш мы ўзгадвалі у *Главе 1*),затым гэта вэрсія файла захоўваецца ў Git-сховішчы (Git зьвяртаецца да іх як да бінарных даньняў), і гэтая кантрольная сума дадаецца ў індэкс:

	$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'

Калі вы ствараеце каміт камандай `git commit`, Git вылічвае кантрольную суму кожнага падкаталёга (у нашым выпадку, толькі каранёвага каталёга) і захоўвае аб'екты для гэтага дрэва ў Git-сховішчы. Затым Git стварае аб'ект для каміта, які мае метаданьні і паказальнік на корань праектнага дрэва. Такім чынам, Git можа ўзнавіць цякучы стан, калі гэта спатрэбіцца.

Цяпер вашае Git-сховішча утрымлівае пяць аб'ектаў: па аднаму масіву бінарных даньняў для зьмесьціва кожнага з трох файлаў, адно дрэва, якое пералічвае зьмесьціва каталёга і вызначае адпаведнасьць імёнаў файлаў і масіваў бінарных даньняў, і адзін каміт з паказальнікам на корань гэтага дрэва і ўсе метаданьні каміта. Сьхематычна, даньні ў вашым Git-сховішчы выглядаюць, як паказана на Малюнку 3-1.

Insert 18333fig0301.png 
Малюнак 3-1. Даньні сховішча з адзіным камітам.

Калі вы зробіце нейкія зьмены і зафіксуеце іх, наступны каміт захавае паказальнік на каміт, які йшоў непасрэдна перад ім. Пасьля ячшэ двух камітаў вашая гісторыя можа выглядаць, як паказана на Малюнку 3-2.

Insert 18333fig0302.png 
Малюнак 3-2. Даньні аб'ектаў Git у выпадку некалькіх камітаў.

Галіна ў Git - гэта наўпрост лёгкаважкі румомы паказальнік на адзін з гэтых трох камітаў. Імя галіны па празвызначэньню ў Git - master. Калі вы ў пачатку ствараеце каміты, вам даецца галіна master, якая паказвае на апошні зроблены каміт. Пры кожным новым каміце, паказальнік рухаецца ўперад аўтаматычна.

Insert 18333fig0303.png 
Малюнак 3-3. Галіна паказвае на гісторыю камітаў.

Што адбываецца, калі вы ствараеце новую галіну? Так, гэтым вы ствараеце новы паказальнік, які вы можаце перамяшчаць. Скажам, вы ствараеце новую галіну пад назвай testing. Гэта робіцца камандай `git branch`:

	$ git branch testing

Эта команда создает новый указатель на тот самый коммит, на котором вы сейчас находитесь (см. Рисунок 3-4).

Гэтая каманда стварае новы паказальнік на той самы каміт, на якім вы зараз знаходзіцеся (гл. Малюнак 3-4).

Insert 18333fig0304.png 
Малюнак 3-4. Некалькі галінаў, якія паказваюць на гісторыю камітаў.

Адкуль Git ведае, на якой галіне вы знаходзіцеся ў дадзены момант? Ён захоўвае сьпецыяльны паказальнік, які называецца HEAD (верхавіна???). Майце на ўвазе, што гэта моцна адрозьніваецца ад канцэпцыі HEAD у іншых СКВ, такіх як Subversion ці CVS, да якіх вы магчыма прывыклі. У Git гэта паказальнік на лякальную галіну, на якой вы знаходзіцеся. У дадзеным выпадку вы ўсё ячшэ на галіне master. Каманда git branch толькі стварыла новую галіну, але яна не пераключыла вас на яе (гл. Малюнак 3-5).

Insert 18333fig0305.png 
Малюнак 3-5. Файл HEAD паказвае на цякучую галіну.

Каб перайсьці на існуючую галіну, вам неабходна выканаць каманду `git checkout`. Давайце пяройдзем на новую галіну testing:

	$ git checkout testing

Гэтае дзеяньне перамяшчае HEAD так, каб той паказваў на галіну testing (гл. Малюнак 3-6)

Insert 18333fig0306.png
Малюнак 3-6. HEAD паказвае на іншую галіну, калі вы іх пераключаеце.

У чым важлівасьць гэтага дзеяньня? Давайце зробім ячшэ адзін каміт:

	$ vim test.rb
	$ git commit -a -m 'made a change'

На Малюнку 3-7 паказаны вынік.

Insert 18333fig0307.png 
Малюнак 3-7. Галіна, на якую паказвае HEAD, рухаецца ўперад з кожным камітам.

Гэта цікава, таму што цяпер вашая галіна testing перасунулася ўперад, але вашая галіна master усё ячшэ паказвае на каміт, на якім вы былі, калі выконвалі `git checkout`, каб пераключыць галіны. Давайце пяройдзем назад на галіну master:

	$ git checkout master

На Малюнку 3-8 можна пабачыць вынік.

Insert 18333fig0308.png 
Малюнак 3-8. HEAD перамяшчаецца на іншую галіну пры  checkout'е.

Гэтая каманда выканала два дзеяньні. Яна перасунула паказальнік HEAD назад на галіну master і вярнула файлы ў вашым працоўным каталёзе назад, у адпаведнасьці з здымкам стану, на які паказвае master. Гэта таксама азначае, што зьмены, якія вы робіце з гэтага моманту, будуць адгаліноўвацца ад старой вэрсіі праекта. Гэта цалкам адкочвае???? зьмены, якія вы часова рабілі на галіне testing. Такім чынам, далей вы можаце рухацца ў іншых накірунку.

Давайце зноў зробім трохі зьменаў і зафіксуем іх:

	$ vim test.rb
	$ git commit -a -m 'made other changes'

Цяпер гісторыя вашага праекту разгалінавалась (см. Малюнак 3-9). Вы стварылі новую галіну, перайшлі на яе, папрацавалі на ёй трохі, пераключыліся назад на асноўную галіну і выканалі новую працу. Абодвы гэтая зьмяненьні ізаляваныя на асобных галінах: вы можаце пераключыцца туды і назад паміж галінамі і зьміць іх, калі будзеце гатовы. І вы зрабілі ўсё гэта простымі камандамі `branch` і `checkout`.

Insert 18333fig0309.png 
Малюнак 3-9. Гісторыя з галінамі, якія разыйшліся.

З-за таго, што галіна ў Git на самой справе зьяўляецца простым файлам, які утрымлівае 40 сімвалаў кантрольнай сумы SHA-1 каміта, на які ён паказвае, стварэньне і выдаленьне галінаў практычна безвыдаткова. Стварыць новую галіну можна так жа хутка і проста, як запісаць 41 байт (40 сімвалаў??? + сімвал перахода на новы радок). 

Гэта адрозьніваецца ад таго, як у большасьці СКВ робіцца галінаваньне. Там гэта прыводзіць да капіяваньня ўсіх файлаў праекта у іншую тэчку. Гэта можа запатрабаваць некалькіх сякундаў ці нават хвілінаў, у залежнасьці ад памеру праекту, тады як у Git гэты працэс заўсёды імгненна. Таксама, з-за таго, што мы запамінаем продкаў для кожнага каміта, пошук неабходнай базавай вэрсіі для зьліцьця ўжо аўтаматычна выкананы за нас, і ўвогуле зьліцьцё робіцца лёгка. Гэтыя асаблівасьці дапамагаюць заахвочваць распрацоўнікаў да частага стварэньня і выкарыстаньня галінаў.

Давайце зразумеем, чаму вам неабходна так рабіць.

## Падставы галінаваньня і зьліцьця ##

Давайце разгледзім просты прыклад галінаваньня і зьліцьця з такім працэсам працы, які вы б маглі выкарыстаць у сапраўднай распрацоўцы. Вы будзеце рабіць наступнае:

1.	Працаваць з вэб-сайтам.
2.	Створыце галіну для новай гісторыі, над якой вы працуеце.
3.	Выканаеце нейкую працу на гэтай галіне.

На гэтым этапе вы атрымаеце атрымаеце сыгналь аб тым, што зараз маецца крытычная іншая праблема, і яе вам трэба тэрмінова вырашыць. Вы робіце наступнае:

1.	Вярнецеся на вытворучую галіну.
2.	Створыце галіну для выпраўленьня памылкі.
3.	Пасьля тэставаньня, зьліцё галіну з выпраўленьнем і абнавіце аддаленае сховішча.
4.	Пераключыцеся да перапыненай гісторыі і працягніце працу.

### Падставы галінаваньня ###

Для пачатку ўявім, што вы працуеце з сваім праектам і ўжо маеце некалькі камітаў (гл. Малюнак 3-10).

Insert 18333fig0310.png 
Малюнак 3-10. Кароткая і простая гісторыя камітаў.

Вы вырашылі, што будзеце працаваць над праблема №53 з сыстэмы адсочваньня памылак, якую выкарыстоўвае вашая кампанія. Зразумела, Git не прывязаны да якой-небудзь вызначанай сыстэмы адсочваньня памылак. Наўпрост з-за таго, што праблема №53 зьяўляецца асноўнай задачай, над якой вы хочыце працаваць, вы створыце новую галіну для працы зь ёй. Каб стварыць галіну і адразу перайсьці на яе, вы можаце выканаць каманду `git checkout` з ключом `-b`:

	$ git checkout -b iss53
	Switched to a new branch "iss53"

Гэта скарачэньне для:

	$ git branch iss53
	$ git checkout iss53

Малюнак 3-11 паказвае вынік.

Insert 18333fig0311.png 
Малюнак 3-11. Стварэньне новай галіны / паказальніка.

Пад час працы над вашым вэб-сайтам, вы робіце некалькі камітаў. Гэтыя дзеяньні перасоўваюць галіну `iss53` наперад таму, што вы на яе перайшлі (гэта значыць ваш HEAD паказвае на яе; гл. Малюнак 3-12):


	$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'

Insert 18333fig0312.png 
Малюнак 3-12. Галіна iss53 перасунулася наперад пад час працы.

Цяпер вы атрымаеце сыгналь аб тым, што ёсьць праблема з вэб-сайтам, якую неабходна хутка выправіць. З Git, ў вас няма патрэбы ствараць латку разам з тымі зьменамі, якія вы ўжо зрабілі для `iss53`. А таксама ня трэба прыкладваць шмат намаганьняў, каб адмяніць гэтыя зьмены перад тым, як вы зможаце пачаць працаваць над рашэньнем тэрміновай праблемы. Усё, што вам трэба зрабіць, гэта перайсьці на галіну master.

Аднак, перад тым як гэта зрабіць, майце на ўвазе, што калі ў вашай працэўной тэчцы ці індэксе маюцца незафіксаваныя зьмены, якія канфліктуюць з галіной, на якую вы пераходзіце, Git не дазволіць пераключыць галіны. Лепей за ўсё пры пераключэньні галінаў мець чысты працоўны стан. Існуе некалькі спосабаў дасягнуць гэтага (а менавіта, хаваць працу і правіць каміты), якія мы разгледзім пазьней. А на дадзены момант уявім, што вы зафіксавалі ўсе зьмены, і можаце пераключыцца назад на галіну master:

	$ git checkout master
	Switched to branch "master"

Цяпер працоўны каталёг праекту знаходзіцца ў тым жа стане, што і ў момант пачатку працы над праблемай №53, так што вы можаце сканцэнтравацца на хуткім зьмяненьні. Вельмі важліва запомніць: Git вяртае ваш працоўны каталёг да здымка стану таго каміта, на які паказвае галіна, на якую вы пераходзіце. Ён дабаўляе, выдаляе і зьмяняе файлы аўтаматычна, каб гарантаваць, што стан вашай працоўнай копіі ідэнтычнае апошняму каміту на галіне.

Так, вам трэба хутка выправіць памылку. Давайце створым для гэтага галіну, на якой вы будзеце працаваць (гл. Малюнак 3-13):


	$ git checkout -b 'hotfix'
	Switched to a new branch "hotfix"
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: "fixed the broken email address"
	 1 files changed, 0 insertions(+), 1 deletions(-)

Insert 18333fig0313.png 
Малюнак 3-13. Галіна для рашэньня тэрміновай праблемы базуецца на галіне master.

Вы можаце запусьціць тэсты, пераканацца, што рашэньне працуе, і зьліць зьмены назад на галіну master, каб уключыць яго ў сховішча. Гэта робіцца з дапамогай каманды `git merge`:

	$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)

Напэўна, вы заўважылі фразу "Fast forward" у гэтым зьліцьці. Так як галіна, якую вы зьлівалі, паказвала на каміт, які зьяўляецца прамым нашчадкам каміта, на якім вы знаходзіцеся, Git перасоўвае паказальнік наперад. Іншымі словамі, калі вы спрабуеце зьліць адзін каміт з іншым, які можа быць дасягнуты, калі вы ідзяце па гісторыі першага каміта, Git зпрашчае рэчы, перасоўваючы паказальнік наперад, так як няма разыходзячых зьменаў для зьліцьця іх у адно цэлае. Гэта называецца "fast forward" (перамотка).

Вашыя зьмены цяпер у здымку стану каміта, на які паказвае галіна master, і вы можаце ўключыць зьмены ў сховішча (гл. Малюнак 3-14).

Insert 18333fig0314.png 
Малюнак 3-14. Пасьля зьліцьця галіна master паказвае туды ж, куды і галіна hotfix.

Пасьля таго, як вельмі важлівая праблема вырашана, вы гатовыя вярнуцца назад да працы, якую рабілі, перад тым як былі перапынены. Аднак, спачатку выдаліце галіну `hotfix`, так як яна больш не патрэбна - галіна `master` ужо паказвае на тое ж месца. Вы можаце выдаліць галіну з дапамогай опцыі `-d` да `git branch`:

	$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).

Цяпер вы можаце вярнецца назад да працоўнай галіны для праблемы №53 і працягнуць працаваць зь ёй (см. Малюнак 3-15):

	$ git checkout iss53
	Switched to branch "iss53"
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: "finished the new footer [issue 53]"
	 1 files changed, 1 insertions(+), 0 deletions(-)

Insert 18333fig0315.png 
Малюнак 3-15. Каліна iss53 можа рухацца наперад незалежна.

Варта нагадаць, што праца, зробленая на галіне `hotfix`, не ўключана ў файлы на галіне `iss53`. Калі вам гэта неабходна, вы можаце выканаць зьліцьцё галіны `master` у галіну `iss53` з дапамогай каманды `git merge master`. Ці вы можаце пачакаць з інтэграцыяй зьменаў да той пары, пакуль не вырашылі ўключыць зьмены на `iss53` у галіну `master`.

### Падставы зьліцьця ###

Уявіце сабе, што вы разабралісь з праблемай №53 і гатовы аб'яднаць гэтую галіну і сваю `master`. Каб гэта зрабіць, вы выканайце зьліцьцё вашай галіны `iss53` у галіну `master` таксама так, як вы рабілі раней з галіной `hotfix`. Ўсё што вы павінны зрабіць - перайсьці на гэтую галіну, у якую вы хочаце ўнесьці свае зьмены і выканаць загад `git merge`:

	$ git checkout master
	$ git merge iss53
	Merge made by recursive.
	 README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)

Зараз зьліцьцё выглядае крышку ня так, як для галіны `hotfix`, якое вы рабілі раней. У дадзеным выпадку вашая гісторыя разпрацоўкі разьдзялілась у нейкай кропцы. Так як каміт на той галіне, на якой вы знаходзіцеся, не зьяўляецца прамым нашчадкам для галіну, якую вы зьліваеце, Git'у давядзецца зрабіць некаторую працу. У гэтым выпадку Git робіць простае троххадовае зьліцьцё, пры гэтым выкарыстоўвае два здымкі станаў сховішча, на якія паказваю верхавіны галінаў, і агульны здымак-прабацька!!! для гэтых двух галінаў. На малюнку 3-16 выдзелены тры здымкі, якія Git будзе выкарыстоўваць для зьліцьця ў гэтым выпадку.

Insert 18333fig0316.png
Малюнак 3-16. Git аўтаматычна вызначае найлепшага агульнага продак для зьвіцьця галінаў.

Замест таго, каб проста перасунуць паказальнік галіны наперад, Git стварае новы здымак стану, які зьяўляецца вынікам троххадовага зьліцьця, і аўтаматычна створыць новы каміт, які паказвае на гэты новы здымак стану (глядзі Малюнак 3-17). Такі каміт называюць каміт-зьліцьцё, так як ён зьяўляецца незвычайным з-за таго, што мае больш аднаго продак.

Варта адзначыць, што Git вызначае найлепшага агульнага продка для зьліцьця галінаў; у CVS ці Subversion (вэрсіі ранейшай за 1.5) гэтага не адбываецца. Разпрацоўнік павінен сам паказаць падставу для зьліцьця. Гэта робіць зьліцьцё у Git значна больш простым заняткам, чым у іншых сыстэмах.

Insert 18333fig0317.png
Малюнак 3-17. Git аўтаматычна стварае новы каміт, які ўтрымлівае вынікі зьліцьця.

Цяпер, калі вы ажыцьцявілі зьліцьцё вашых напрацовак, галіна `iss53` вам больш не патрэбна.Мажаце выдаліць яе і затым уручную закрыць картку(ticket) у вашай сыстэме: 

	$ git branch -d iss53

### Падставы канфліктаў пры зьліцьці ###

Часам працэс зьліцьця не ідзе гладка. Калі вы зьмянілі адну і тую ж частку файла па-рознаму ў дзьвух галінах, якія вы зьбіраецеся аб'яднаць, Git ня зможа зрабіць гэта чыста. Калі ваша рашэньне праблемы №53 зьмяняе тую ж частку файла, што і `hotfix`, вы атрымаеце канфлік зьліцьця, і выглядаць ён будзе прыкладна наступным чынам:

	$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.

Git не стварыў новы каміт для зьліцьця. Ён прыпыніў гэты працэс да той пары, пакуль вы ня вырашыце канфлікт. Калі вы хочаце паглядзець, якія файлы не прайшлі ў зьліцьцё (на гэтым этапе пасьля ўзьнікненьня канфлікта), можаце выканаць каманду `git status`:

	[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#   (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#	unmerged:   index.html
	#

Усё, што мае адносіны да канфлікту зьліцьця і што не было вырашана, адзначана як unmerged. Git дабаўляе стандартныя маркеры да файлаў, якія маюць канфлікт, так як вы можаце адкрыць іх уручную!!! і вырашыць гэтыя канфлікты. Ваш файл утрымлівае сэкцыю, якая выглядае прыкладна так:

	<<<<<<< HEAD:index.html
	<div id="footer">contact : email.support@github.com</div>
	=======
	<div id="footer">
	  please contact us at support@github.com
	</div>
	>>>>>>> iss53:index.html

У верхняй частцы блёка (усё што вышэй за `=======`) гэта вэрсія з HEAD (вашай галіны master, так як менавіта на яе вы перайшлі перад выкананьнем каманды merge), усё што знаходзіцца ў ніжняй частцы - вэрсія ў `iss53`. Каб вырашыць канфлікт вы павінны выбраць адну з гэтых частак, ці неяк аб'яднаць зьмест па свайму рашэньню. Напрыклад, вы можаце вырашыць гэты канфлікт заменай ўсяго блёка, паказанага вышэй, наступным блёкам:

	<div id="footer">
	please contact us at email.support@github.com
	</div>

Гэта рашэньне ўтрымлівае па трохі з кожнай часткі, і я цалкам выдаліў радкі `<<<<<<<`, `=======` і `>>>>>>>`. Пасьля гэтага, як вы вырашылі кожную з гэтых сэкцыяў з кожным канфліктным файлам, выканайце `git add` для кожнага кафліктнага файла. Індэксаваньне будзе азначаць для Git, што ўсе канфлікты ў файле цяпер вырашаныя.

Калі вы захочыце выкарыстаць графічныя прылады для вырашэньня канфліктаў, можаце выканаць загад `git mergetool`, які запусьціць адпаведны графічную прыладу і пакажа канфліктныя сытуацыі:

	$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html

	Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):

Калі вы можаце выкарыстаць іншую прыладу для зьліцьця, акрамя прадвызначанай (Git выбраў `opendiff` для мяне, так як я выканаў каманду на Mac). Вы можаце ўбачыць усе магчымыя прылады, паказаныя вышэй пасьля “merge tool candidates”. Пазначце назвы пажаданай для вас прылады. У *Главе 7* мы абмяркуем, як зьмяніць гэтае прадвызначанае значэньне для вашай сыстэмы.

Пасьля таго, як вы выйдзіце з прылады для выкананьня зьліцьця, Git спытае вас, было яно пасьпяховым ці не. Калі вы адказваеце, што так - файл індэксуецца (дадаецца ў вобласьць для каміта), каб даць вам зразумець, што канфлікт вырашаны.

Можаце выканаць `git status` ячшэ раз, каб пераканацца, што ўсе канфлікты былі вырашаныя:

	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	modified:   index.html
	#

Калі вы задаволеныя тым, што атрымалі, і пераканаліся, што ўсе канфлікты вырашаныя, файлы праіндэксаваныя, можаце выканаць `git commit` для завяршэньня зьліцьця. Прадвызначана паведамленьне каміта будзе выглядаць прыкладна так:

	Merge branch 'iss53'

	Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.
	# If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.
	#

Вы можаце дапоўніць гэтае паведамленьне інфармацыяй аб тым, як вы вырашылі канфлікт, калі лічаце, што гэта можа быць карысна для іншых у будучыні. Напрыклад, можаце паказаць чаму вы зрабілі тое, што зрабілі, калі гэта безумоўна не відавочна.

## Кіраваньне галінамі ##

Цяпер, калі вы паспрабавалі ствараць, аб'ядноўваць і выдаляць галіны, пара пазнаёміцца зь некаторымі прыладамі для кіраваньня галінамі. Калі вы пачнеце пастаянна выкарыстоўваць галіны, гэтыя прылады вельмі вам спатрэбяцца.

Загад `git branch` робіць крыху больш, чым проста стварае і выдаляе галіны. Калі вы выканаеце яе без аргумэнтаў, дык атрымаеце просты сьпіс вашых цякучых галінаў:

	$ git branch
	  iss53
	* master
	  testing

Зьвярніце ўвагу на сымбаль `*`, які стаіць перад галіной `master`: ён паказвае на тую галіну, на якой вы знаходзіцеся на дадзены момант. Гэта азначае, што калі вы зараз выканаеце каміт, галіна `master` перамесьціцца ўперад у адпаведнасьці з вашымі апошнімі зьменамі. Каб паглядзець апошні каміт на кожнай з галінаў, выканайце загад `git branch -v`:

	$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes

Іншая карысная магчымасьць для высьвятленьня стану вашых галінаў складаецца з таго, каб пакідаць у гэтым сьпісе толькі тыя галіны, для якіх вы выканалі (ці не выканалі) зьліцьцё з галіной, на якой зараз знаходзіцеся. Для гэтых мэтаў у Git, пачынаючы з вэрсіі 1.5.6 ёсьць опцыя `--merged` і `--no-merged`. Каб паглядзець тыя галіны, якія вы ужо зьлілі з цякучай, выканайце загад `git branch --merged`:

	$ git branch --merged
	  iss53
	* master

Так як вы ўжо выконвалі зьліцьцё для галіны `iss53` раней, вы бачыце яе ў сваім сьпісе. Нядрэннай ідэяй было б выдаліць загадам `git branch -d` тыя галіны з гэтага сьпісу, перад якімі няма сібмала `*`; вы ўжо аб'ядноўвалі напрацоўкі з гэтых галінаў з іншай галіной, так што вы нічога не губляеце.

Каб паглядзець усе галіны, якія утрымліваюць напрацоўкі, якія вы яшчэ не аб'ядналі з цякучай галіной, выканайце загад `git branch --no-merged`:

	$ git branch --no-merged
	  testing

Вы бачыце галіну, якая засталася. Так як яна утрымлівае ячшэ не зьлітыя напрацоўкі, спроба выдаліць яе загадам `git branch -d` не закончыцца посьпехам:

	$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.
	If you are sure you want to delete it, run 'git branch -D testing'.

Калі вы сапраўды хочаце выдаліць галіну і згубіць напрацоўкі, вы можаце зрабіць гэта пры дапамозе опцыі `-D`, як паказана ў падказцы.

## Прыемы працы зь галінамі ##

Цяпер, калі вы пазнаёміліся з падставімі галінаваньня і зьляцьця, што вар рабіць з галінамі далей? У гэтым разьдзеле мы разглядзім некаторыя стандартныя прыёмы працы, якія робяцца магчымымі, дзякуючы лёгкаму ажыцьцяўленьня галінаваньня. І вы зможыце выбіраць, ці уключаць вам нейкія з іх у свой цыкл разпрацоўкі.

### Доўгажывучыя галіны ###

Так як Git выкарыстоўвае простае троххадовае зьліцьцё, зьліваць адну галіну з іншай на працягу вялікага прамежка часу даволі проста. Гэта значыць вы можыце мець некалькі галінаў, якія заўсёды адчыненыя і якія вы выкарыстоўваеце для розных стадый вашага цыкла разпрацоўкі; вы можаце рэгулярна зьліваць адну зь іх зь іншай;

Шмат разпрацоўнікаў Git-а вядуць свой працоўны працэс у адпаведнасьці з гэтай ідэяй. Напрыклад, стабільны код разьмяшчаецца толькі ў галіне `master` ― адзіны стабільны код, які быў ці будзе выпушчаны. Яны маюць іншую паралельную галіну, якая завецца `develop` (разпрацоўка) ці `next` (наступная), зь якой яны працуюць ці выкарыстоўваюць для праверкі на стабільнасьць - яна не абавязкова заўсёды зьяўляецца стабільнай, але калі яна прымае стабільны стан, можна зьліць яе з `master`. Яна выкарыстоўваецца, каб у яе уключаліся зьмены з кароткіх галінаў (такіх як галіна `iss53`, зь якой вы мелі справу раней) калі яны гатовыя, каб пераканацца, што яны пасьпяхова праходзяць усе тэсты і не выклікаюць памылак.

Насамрэч жа, мы кажым пра паказальнікі, якія перасоўваюцца ўверх па лініі камітаў, якія вы робіце. Стабільныя галіны далёка ўнізе лініі вашай гісторыі камітаў, найбольш сьвежыя галіны знаходзяцца бліжэй да верхавіны гэтай лініі (глядзі Малюнак 3-18).

Insert 18333fig0318.png 
Малюнак 3-18. Больш стабільныя галіны як правіла знаходзяцца далей у гісторыі камітаў.

Увогуле, аб гэтым прасьцей думаць як пра сіласныя вежы, калі набор камітаў пераходзіць у больш стабільную вежу толькі тады, калі ён увесь пратэставаны (глядзі Малюнак 3-19).

Insert 18333fig0319.png 
Малюнак 3-19. Можа быць карыстна думаць пра галіны як пра сіласныя вежы.

Вы можаце прымяняць гэтую ідэю для некалькіх розных узроўняў стабільнасьці. Некаторыя вялікія праекты таксама выкарыстоўваюць галіну `proposed` ці `pu` (proposed updates ― меркаваныя зьмены), якія ўключаюць у сябе галіны, не гатовыя для пераходу ў галіны `next` ці `master`. Ідэя такая, што вашыя галіны знаходзяцца на розных узроўнях стабільнасьці; калі яны дасягаюць больш высокага ўзроўня стабільнасьці, яны зьліваюцца з галіноў, якая стаіць на больш высокім узроўні. Зноў жа, не абавязкова мець доўгажывучыя галіны, але часта гэта вельмі карысна, асабліва калі вы маеце справу з вялікімі і складанымі праектамі.

### Тэматычныя галіны ###

Тэматычныя галіны, аднак, карысныя ў праектах любога памеру. Тэматычная галіна - недаўгатэрміновая галіна, якую вы ствараеце і выкарыстоўваеце для нейкай асобнай магчымасьці ці дапаможнай працы. Гэта тое, чаго вы верагодна ніколі не рабілі з сыстамамі кіраваньня вэрсіямі раней, бо стварэньне і зьліцьцё галінаў звычайна патрабуе шмат выдаткаў. Але ў Git водзіцца ствараць галіны, працаваць над імі, аб'ядноўваць і выдаляць іх па некалькі разоў у дзень.

Вы бачылі падобнае ў апошнім разьдзеле, дзе вы стваралі галіны `iss53` і `hotfix`. Вы зрабілі некалькі камітаў на гэтых галінах і выдалілі іх адразу пасьля аб'яднаньня з вашай асноўнай галіной. Такая тэхніка дазваляе вам хутка і паўнавартасна пераключаць кантэкст. Калі ўсе зьмены ў дадзенай галіне адносяцца да вызначанай тэмы, дастаткова проста адсочваць, што адбывалася пад час працы з кодам. Вы можаце захаваць там зьмены на некалькі хвілінаў, дзён ці месяцаў, а затым, калі яны гатовыя, зьліць іх з асноўнай галіной, незалежна ад парадка, у якім іх стваралі ці працавалі над імі.

Разглядзім прыклад, калі выконваецца нейкая праца (у галіне `master`), робіцца адгаліваньне для рашэньня праблемы (`iss91`), выконваецца няшмат працы на ей, робіцца адгаліваньне іншай галіны для іншага шляху рашэньня той жа задачы (`iss91v2`), ажыцьцяўляецца пераход назад на вашую асноўную галіну (`master`) і выкананьне працы на ёй, затым робіцца адгаліваньне ад яе для выкананьня чагосьці, у чым вы не ўпэўненыя, што гэта добрая ідэя (галіна `dumbidea`). Вашая гісторыя камітаў будзе выглядаць прыкладна так як на Малюнку 3-20.

Insert 18333fig0320.png 
Малюнак 3-20. Гісторыя камітаў зь некалькімі тэматычнымі галінамі.

Цяпер уявім, вы вырашылі, што вам больш падабаецца іншае рашэньне для вашай задачы (`iss91v2`);  і вы паказваеце галіну `dumbidea` вашым калегам і атрымліваецца, што яна проста геніальная. Так што вы можаце выкінуць арыгінальную галіну `iss91` (пры гэтым губляеце каміты C5 і C6) і зьліць дзьве іншыя. Тады вашая гісторыя будзе выглядаць як на Малюнку 3-21.

Insert 18333fig0321.png 
Малюнак 3-21. Вашая гісторыя пасьля зьліцьця dumbidea і iss91v2.

Важліва запомніць, што калі вы выконваеце ўсе гэтыя дзеяньні, галіны зьяўляюцца поўнасьцю лякальнымі. Калі вы выконваеце галінаваньне і зьліцьцё, ўсё адбываецца толькі ў вашым сховішчы - сувязь з сэрверам не ажыцьцяўляецца.

## Аддаленыя галіны ##

Аддаленыя галіны - гэта спасылкі на стан галінаў у вашых аддаленых сховішчах. Гэта лякальныя галіны, якія нельга перамяшчаць; яны рухаюцца аўтаматычна кожны раз, калі вы ажыцьцяўляеце сувязь у сеціве. Аддаленыя галіны дзейнічаюць як закладкі для нагадваньня аб тым, дзе знаходзіліся галіны ў аддаленых сховішчах пад час апошняга падключэньня да іх.

Яны маюць выгляд `(імя выд. сховішч.)/(галіна)`. Напрыклад, калі вы хочаце паглядзець, як выглядала галіна `master` на сэрверы `origin` пад час апошняга злучэньня зь ім, праверце галіну `origin/master`. Калі вы з партнёрам працавалі над адной праблемай, і ён разьмясьціў галіну `iss53`, у вас можа быць свая лякальная галіна `iss53`; але тая галіна на сэрверы будзе паказваць на каміт у `origin/iss53`.

Усё гэта магчыма зьбівае з панталыку, пагэтаму давайце разглядзім прыклад. Скажам, у вас ёсьць Git-сэрвер у сеціве на `git.ourcompany.com`. Калі вы зклянуеце (clone) зь яго, Git аўтаматычна назаве яго для вас `origin`, забярэ зь яго ўсе зьвесткі, створыць паказальнік на яго галіну `master` і назаве яго лякальна `origin/master` (але вы ня зможыце яго рухаць). Git таксама зробіць вам вашую асабістую галіну `master`, якая будзе пачынацца там жа, дзе і галіна `master` у origin, так што вам будзе з чым пачаць працаваць (глядзі Мал. 3-22).

Insert 18333fig0322.png 
Малюнак 3-22. Клянаваньне Git-праекту дае вам асабістую галіну master і origin/master, які паказвае на каліну master у origin.

Калі вы штосьці зробіце ў вашай лякальнай галіне `master`, а тым часам хтосьці ячшэ адправіць (push) зьмены на `git.ourcompany.com` і абнавіць там галіну master, дык вашыя гісторыя працягнуцца па-рознаму. Да таго ж, да тае пары, пакуль вы не зьвяжыцеся з сэрверам origin, ваш паказальнік `origin/master` ня будзе зрушвацца (глядзі Малюнак 3-23).

Insert 18333fig0323.png 
Малюнак 3-23. Пры выкананьні лякальнай працы і адпраўцы кімсьці зьменаў на аддалены сэрвер, кожная гісторыя працягваецца па-рознаму.

Для сінхранізацыі вашай працы, выконваецца загад `git fetch origin`. Гэты загад шукае якому сэрверу адпавядае origin (у нашым выпадку гэта `git.ourcompany.com`); выцягвае адтуль усе зьвесткі, якіх у вас ячшэ няма, і абнаўляе вашае лякальнае сховішча зьвесткаў; перасоўвае паказальнік `origin/master` на новую пазыцыю (глядзі Малюнак 3-24).

Insert 18333fig0324.png 
Малюнак 3-24. Загад git fetch абнаўляе вашыя выдаленыя спасылкі.

Каб прадэманстраваць тое, як будуць выглядаць выдаленыя галіны ў сытуацыі зь некалькімі выдаленымі сэрверамі, уявім, што ў вас ёсьць ячшэ адзін унутраны Git-сэрвер, які выкарыстоўваецца для разпрацоўкі толькі адной з вашых камандаў разпрацоўнікаў. Гэты сэрвер знаходзіцца на `git.team1.ourcompany.com`. Вы можаце дабавіть яго ў якасьці новай выдаленай спасылкі на праект, над якім вы зараз працуеце з дапамогай каманды `git remote add`, таксама як было апісана ў Главе 2. Дайце гэтаму выдаленаму сэрверу імя `teamone`, якое будзе скарачэньне для поўнага URL (глядзі Малюнак 3-25). 

Insert 18333fig0325.png 
Малюнак 3-25. Дабаўленьне дадатковага падаленага сэрвера.

Теперь можете выполнить `git fetch teamone`, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервер есть только часть данных, которые есть на сервере `origin`, Git не получает никаких данных, но выставляет удалённую ветку с именем `teamone/master`, которая указывает на тот же коммит, что и ветка `master` на сервере `teamone` (смотри Рисунок 3-26).

Цяпер можаце выканаць `git fetch teamone`, каб выцягнуць усё, што ёсьць на сэрверы і няма ў вас. Так як у надзены момант на гэты гэтым сэрверы ёсьць толькі частка зьвестак, якія ёсьць на сэрверы `origin`, Git не атрымлівае ніякіх зьвестак, але выстаўляе аддаленую галіну з імём `teamone/master`, якая паказвае на той жа каміт, што і галіна `master` на сэрверы `teamone` (глядзі Малюнак 3-26).

Insert 18333fig0326.png 
Малюнак 3-26. У вас зьявілася лякальная спасылка на галіну master на teamone-е.

### Адпраўленьне зьменаў ###

Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться. Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.

Если у вас есть ветка `serverfix`, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же как вы отправляли вашу первую ветку. Выполните `git push (удал. сервер) (ветка)`:

	$ git push origin serverfix
	Counting objects: 20, done.
	Compressing objects: 100% (14/14), done.
	Writing objects: 100% (15/15), 1.74 KiB, done.
	Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -> serverfix

Это в некотором роде сокращение. Git автоматически разворачивает имя ветки `serverfix` до `refs/heads/serverfix:refs/heads/serverfix`, что означает “возьми мою локальную ветку serverfix и обнови из неё удалённую ветку serverfix”. Мы подробно обсудим часть с `refs/heads/` в Главе 9, но обычно можно её опустить. Вы можете сделать также `git push origin serverfix:serverfix`, что означает то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”. Можно использовать этот формат для отправки локальной ветки в удалённую ветку, которая называется по-другому. Если вы не хотите, чтобы ветка называлась `serverfix` на удалённом сервере, то вместо предыдущей команды выполните `git push origin serverfix:awesomebranch`. Так ваша локальная ветка `serverfix` отправится в ветку `awesomebranch` удалённого проекта.

В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает `serverfix` на сервере, как удалённую ветку `origin/serverfix`:

	$ git fetch origin
	remote: Counting objects: 20, done.
	remote: Compressing objects: 100% (14/14), done.
	remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.
	From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -> origin/serverfix

Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку `serverfix` — только указатель `origin/serverfix`, который вы не можете менять.

Чтобы слить эти наработки в вашу текущую рабочую ветку, можете выполнить `git merge origin/serverfix`. Если вы хотите иметь собственную ветку `serverfix`, над которой вы сможете работать, можете создать её на основе удалённой ветки:

	$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"

Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и `origin/serverfix`.

### Отслеживание веток ###

Получение локальной ветки с помощью `git checkout` из удалённой ветки автоматически создаёт то, что называется _отслеживаемой веткой_. Отслеживаемые ветки это локальные ветки, которые напрямую связаны с удалённой веткой. Если находясь на отслеживаемой ветке, вы наберёте `git push`, Git автоматически знает на какой сервер и в какую ветку отправлять изменения. Аналогично, выполнение `git pull` на одной из таких веток сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.

При клонировании репозитория, как правило, автоматически создаётся ветка `master`, которая отслеживает `origin/master`. Вот почему `git push` и `git pull` работают "из коробки" и не требуют других аргументов. Однако, если хотите, можете настроить другие отслеживаемые ветки — те, которые не отслеживают ветки в `origin`, и те, которые не отслеживают ветку `master`. Простой случай это тот пример, который вы только что видели — выполнение `git checkout -b [ветка] [удал. сервер]/[ветка]`. Если вы используете Git версии 1.6.2 или более позднюю, можете также воспользоваться сокращением `--track`:

	$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"

Чтобы настроить локальную ветку с именем отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:

	$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "sf"

Теперь ваша локальная ветка sf будет автоматически отправлять (push) и получать (pull) изменения из origin/serverfix.

### Удаление веток на удалённом сервере ###

Предположим, что вы закончили с удалённой веткой. Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку `master` на вашем удалённом сервере (или какую-то другую ветку, где у вас находится стабильный код). Вы можете удалить ветку на удалённом сервере используя весьма глупый синтаксис `git push [удал. сервер] :[ветка]`. Если вы хотите удалить ветку `serverfix` на сервере, выполните следующее:

	$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix

Хлоп. Нету больше ветки на вашем сервере. Вам может захотеться сделать закладку на текущей странице, так как эта команда вам понадобится, а синтаксис вы, скорее всего, забудете. Можно запомнить эту команду вернувшись к синтаксису `git push [удал. сервер] [лок. ветка]:[удал. ветка]`, который мы рассматривали немного раньше. Опуская часть `[лок. ветка]`, вы по сути говорите “возьми ничего у меня и сделай это `[удал. ветка]`”.

## Перемещение ##

В Git есть два способа включить изменения из одной ветки в другую: `merge` (слияние) и `rebase` (перемещение). В этом разделе вы узнаете, что такое перемещение, как его осуществлять, почему это удивительный инструмент и в каких случаях вам не следует его использовать.

### Основы перемещения ###

Если вы вернетесь назад к примеру из раздела Слияние (смотри Рисунок 3-27), вы увидите, что вы разделили вашу работу на два направления и выполняли коммиты на двух разных ветках.

Insert 18333fig0327.png
Рисунок 3-27. Впервые разделенная история коммитов.

Наиболее простое решение для объединения веток, как мы уже выяснили, команда `merge`. Эта команда выполняет трехходовое слияние между двумя последними снимками состояний из веток (C3 и C4) и последним общим предком этих двух веток (C2), создавая новый снимок состояния (и коммит), как показано на Рисунке 3-28.

Insert 18333fig0328.png
Рисунок 3-28. Слияние ветки для объединения разделившейся истории разработки.

Однако, есть и другой путь: вы можете взять изменения, представленные в C3, и применить их сверху C4. В Git это называется _перемещение_ (rebasing). При помощи команды `rebase` вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.

В этом примере вы выполните следующее:

	$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command

Это работает следующим образом: находится общий предок для двух веток (на которой вы находитесь сейчас и на которую вы выполняете перемещение); берётся разница, представленная в каждом из коммитов на текущей ветке, и сохраняется во временные файлы; текущая ветка устанавливается на такой же коммит, что и ветка, на которую вы выполняете перемещение; и, наконец, последовательно применяются все изменения. Рисунок 3-29 иллюстрирует этот процесс.

Insert 18333fig0329.png
Рисунок 3-29. Перемещение изменений, сделанных в C3, на C4.

На этом этапе можно переключиться на ветку master и выполнить слияние-перемотку (fast-forward merge) (смотри Рисунок 3-30).

Insert 18333fig0330.png
Рисунок 3-30. Перемотка ветки master.

Теперь снимок состояния, на который указывает C3, точно такой же, что тот, на который указывал C5 в примере со слиянием. Нет никакой разницы в конечном результате объединения, но перемещение выполняется для того, чтобы история была более аккуратной. Если вы посмотрите лог (log) перемещенной ветки, то увидите, что он выглядит как линейная история работы: выходит, что вся работа выполнялась последовательно, когда в действительности она выполнялась параллельно.

Часто вы будете делать это, чтобы удостовериться, что ваши коммиты правильно применяются для удаленных веток — возможно для проекта, владельцем которого вы не являетесь, но в который вы хотите внести свой вклад. В этом случае вы будете выполнять работу в ветке, а затем, когда будете готовы внести свои изменения в основной проект, выполните перемещение вашей работы на `origin/master`. Таким образом, владельцу проекта не придется делать никаких действий по объединению — просто перемотка (fast-forward) или чистое применение патчей.

Заметьте, что снимок состояния, на который указывает последний коммит, который у вас получился, является ли этот коммит последним перемещенным коммитом (для случая выполнения перемещения) или итоговым коммитом слияния (для случая выполнения слияния), есть один и тот же снимок — разной будет только история. Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.

### Более интересные перемещения ###

Вы также можете выполнять перемещение не только для перемещения ветки. Возьмём, например, историю разработки как на Рисунке 3-31. Вы создали тематическую ветку (`server`), чтобы добавить в проект некоторый функционал для серверной части, и сделали коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку server и сделали ещё несколько коммитов.

Insert 18333fig0331.png
Рисунок 3-31. История разработки с тематической веткой, ответвленной от другой тематической ветки.

Предположим, вы решили, что хотите внести ваши изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части, пока они не будут полностью протестированы. Вы можете взять изменения из ветки client, которых нет на server (C8 и C9), и применить их на ветке master при помощи опции `--onto` команды `git rebase`:

	$ git rebase --onto master server client

По сути, это указание “переключиться на ветку client, взять изменения от общего предка веток `client` и `server` и повторить их на `master`”. Это немного сложно; но результат, показанный на Рисунке 3-32, достаточно классный.

Insert 18333fig0332.png
Рисунок 3-32. Перемещение тематической ветки, ответвленной от другой тематической ветки.

Теперь вы можете выполнить перемотку (fast-forward) для вашей ветки master (смотри Рисунок 3-33):

	$ git checkout master
	$ git merge client

Insert 18333fig0333.png
Рисунок 3-33. Перемотка ветки master, чтобы включить изменения из ветки client.

Представим, что вы также решили включить ветку server в основную ветку. Вы можете выполнить перемещение ветки server на ветку master без предварительного переключения на эту ветку при помощи команды `git rebase [осн. ветка] [тем. ветка]` — которая устанавливает тематическую ветку (в данном случае `server`) как текущую и применяет её изменения на основной ветке (`master`):

	$ git rebase master server

Эта команда применит изменения из вашей работы над веткой `server` на вершину ветки `master`, как показано на Рисунке 3-34.

Insert 18333fig0334.png
Рисунок 3-34. Перемещение вашей ветки server на вершину ветки master.

Затем вы можете выполнить перемотку (fast-forward) основной ветки (`master`):

	$ git checkout master
	$ git merge server

Вы можете удалить ветки `client` и `server`, так как вся работа из них включена в основную линию разработки и они вам больше не нужны. При этом полная история вашего рабочего процесса выглядит как на Рисунке 3-35:

	$ git branch -d client
	$ git branch -d server

Insert 18333fig0335.png
Рисунок 3-35. Финальная история коммитов.

### Возможные риски перемещения ###

Все бы хорошо, но кое-что омрачает всю прелесть использования перемещения. Это выражается одной строчкой:

**Не перемещайте коммиты, которые вы выложили в публичный репозиторий.**

Если вы будете следовать этому указанию, все будет хорошо. Если нет — люди возненавидят вас, вас будут презирать ваши друзья и семья.

Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаете новые, которые являются похожими на старые, но в чем-то другими. Если вы выкладываете ваши коммиты куда-нибудь, и другие забирают их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой `git rebase` и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. Все запутается, когда вы в очередной раз попытаетесь включить их работу в свою.

Давайте рассмотрим пример того, как выполненное вами перемещение наработок, представленных для общего доступа, может вызвать проблемы. Представьте себе, что вы клонировали себе репозиторий с центрального сервера и поработали в нем. Ваша история коммитов выглядит как на Рисунке 3-36.

Insert 18333fig0336.png
Рисунок 3-36. Клонирование репозитория и выполнение в нём какой-то работы.

Теперь кто-то ещё выполняет работу, причём работа включает в себя и слияние, и отправляет свои изменения на центральный сервер. Вы извлекаете их и сливаете новую удалённую ветку со своей работой. Тогда ваша история выглядит как на Рисунке 3-37.

Insert 18333fig0337.png
Рисунок 3-37. Извлечение коммитов и слияние их со своей работой.

Далее, человек, выложивший изменения содержащие слияние, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет `git push --force`, чтобы переписать историю на сервере. Затем вы извлекаете изменения с этого сервера, включая и новые коммиты.

Insert 18333fig0338.png
Рисунок 3-38. Кто-то выложил перемещённые коммиты, отменяя коммиты, на которых вы основывали свою работу.

На этом этапе вы вынуждены объединить эту работу со своей снова, даже если вы уже сделали это ранее. Перемещение изменяет у этих коммитов SHA-1 хеши, так что для Git они выглядят как новые коммиты, тогда как на самом деле вы уже располагаете наработками C4 в вашей истории (смотри Рисунок 3-39).

Insert 18333fig0339.png
Рисунок 3-39. Вы снова выполняете слияние для той же самой работы в новый коммит слияния.

Вы вынуждены объединить эту работу со своей на каком-либо этапе, чтобы иметь возможность продолжать работать с другими разработчиками в будущем. После того, как вы сделаете это, ваша история коммитов будет содержать оба коммита — C4 и C4', которые имеют разные SHA-1 хеши , но представляют собой одинаковые изменения и имеют одинаковые сообщения. Если вы выполните команду `git log` когда ваша история выглядит таким образом, вы увидите два коммита, которые имеют одинакового автора и одни и те же сообщения. Это сбивает с толку. Более того, если вы отправите такую историю обратно на сервер, вы добавите все эти перемещенные коммиты в репозиторий центрального сервера, что может ещё больше запутать людей.

Если вы рассматриваете перемещение как возможность наведения порядка и работы с коммитами до того, как выложили их, и если вы перемещаете только коммиты, которые никогда не находились в публичном доступе — всё нормально. Если вы перемещаете коммиты, которые уже были представлены для общего доступа, и люди, возможно, основывали свою работу на этих коммитах, тогда вы можете получить наказание за разные неприятные проблемы.

## Итоги ##

Мы рассмотрели основы ветвления и слияния в Git. Вы должны чувствовать себя уверенно при создании и переходе на новые ветки, переключении между ветками и слиянии локальных веток. Вы также должны иметь возможность делиться своими ветками, выкладывая их на общий сервер, работать с другими людьми над общими ветками и перемещать свои ветки до того, как они были представлены для общего доступа.
