# Галінаваньне ў Git #

Амаль кожная СКВ у разнастайнай форме падтрымлівае галінаваньне. Галінаваньне азначае, што вы адхіляецеся ад асноўнага шляху разпрацоўкі і працягваеце працаваць, не кранаючы асноўную лінію. Для шматлікіх СКВ гэта вельмі дарагі працэс, і часта патрабует ад вас стварэньня новай копіі каталёга з зыходнікамі, што можа запатрабаваць шмат часу для вялікіх праектаў.

Хтосьці кажа, што мадэль галінаваньня ў Git гэта яго “крутая штука“ і яна безумоўна зьяўляецца перавагай для Git у асяродзьдзі СКВ. Што ж у ёй такаго асаблівага? Спосаб галінаваньня ў Git вельмі лёгкаважкі, і гэта робіць апэрацыі галінаваньня імгненнымі, а пераключэньне туды-сюды паміж галінамі адбываецца таксама хутка. У адрозьненьні ад шматлікіх іншых СКВ, Git заахвочвае такі працэс, пры якім галінаваньне і зьліцьцё адбываюцца часта, нават па некалькі разоў на дзень. Разуменьне і выкарыстаньне гэтай функцыйнасьці дае вам унікальную прыладу і можа літаральна зьмяніць тое, як вы ажыцьцяўляеце разпрацоўку.

## Што такое галіна ##

Каб насамрэч зразумець як працуе Git з галінамі, мы павінны зрабіць крок назад і разгледзіць, як Git захоўвае свае даньні. Як вы напэўна памятаеце з *Главы 1*, Git не захоўвае даньні як пасьлядоўнасьць зьменаў ці дэльт(розьніцаў), а як пасьлядоўнасьць здамкаў стану(snapshot). 

Калі вы фіксуеце зьмены ў Git, Git захоўвае аб'ект, які утрымлівае паказвальнік на здымак зьместа індэкса, метаданьні аўтра і каментары і нуль ці больш паказальнікаў на каміты, якія былі прамымі продкамі гэтага каміта: нуль продкаў для першага каміта, адзін - для звычайнага каміта і некалькі - для каміта, атрыманага ў выніку зьліцьця дзьвух ці больш галінаў.

Для нагляднасьці, давайце ўявім, што у вас ёсьць каталёг, у якім знаходзяцца тры файлы, і вы іх ўсе індэксуеце і робіце каміт. Пры падрыхтоўцы файлаў для кожнага зь іх вылічваецца кантрольная сума (SHA-1 хэш мы ўзгадвалі у *Главе 1*),затым гэта вэрсія файла захоўваецца ў Git-сховішчы (Git зьвяртаецца да іх як да бінарных даньняў), і гэтая кантрольная сума дадаецца ў індэкс:

	$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'

Калі вы ствараеце каміт камандай `git commit`, Git вылічвае кантрольную суму кожнага падкаталёга (у нашым выпадку, толькі каранёвага каталёга) і захоўвае аб'екты для гэтага дрэва ў Git-сховішчы. Затым Git стварае аб'ект для каміта, які мае метаданьні і паказальнік на корань праектнага дрэва. Такім чынам, Git можа ўзнавіць цякучы стан, калі гэта спатрэбіцца.

Цяпер вашае Git-сховішча утрымлівае пяць аб'ектаў: па аднаму масіву бінарных даньняў для зьмесьціва кожнага з трох файлаў, адно дрэва, якое пералічвае зьмесьціва каталёга і вызначае адпаведнасьць імёнаў файлаў і масіваў бінарных даньняў, і адзін каміт з паказальнікам на корань гэтага дрэва і ўсе метаданьні каміта. Сьхематычна, даньні ў вашым Git-сховішчы выглядаюць, як паказана на Малюнку 3-1.

Insert 18333fig0301.png 
Малюнак 3-1. Даньні сховішча з адзіным камітам.

Калі вы зробіце нейкія зьмены і зафіксуеце іх, наступны каміт захавае паказальнік на каміт, які йшоў непасрэдна перад ім. Пасьля ячшэ двух камітаў вашая гісторыя можа выглядаць, як паказана на Малюнку 3-2.

Insert 18333fig0302.png 
Малюнак 3-2. Даньні аб'ектаў Git у выпадку некалькіх камітаў.

Галіна ў Git - гэта наўпрост лёгкаважкі румомы паказальнік на адзін з гэтых трох камітаў. Імя галіны па празвызначэньню ў Git - master. Калі вы ў пачатку ствараеце каміты, вам даецца галіна master, якая паказвае на апошні зроблены каміт. Пры кожным новым каміце, паказальнік рухаецца ўперад аўтаматычна.

Insert 18333fig0303.png 
Малюнак 3-3. Галіна паказвае на гісторыю камітаў.

Што адбываецца, калі вы ствараеце новую галіну? Так, гэтым вы ствараеце новы паказальнік, які вы можаце перамяшчаць. Скажам, вы ствараеце новую галіну пад назвай testing. Гэта робіцца камандай `git branch`:

	$ git branch testing

Эта команда создает новый указатель на тот самый коммит, на котором вы сейчас находитесь (см. Рисунок 3-4).

Гэтая каманда стварае новы паказальнік на той самы каміт, на якім вы зараз знаходзіцеся (гл. Малюнак 3-4).

Insert 18333fig0304.png 
Малюнак 3-4. Некалькі галінаў, якія паказваюць на гісторыю камітаў.

Адкуль Git ведае, на якой галіне вы знаходзіцеся ў дадзены момант? Ён захоўвае сьпецыяльны паказальнік, які называецца HEAD (верхавіна???). Майце на ўвазе, што гэта моцна адрозьніваецца ад канцэпцыі HEAD у іншых СКВ, такіх як Subversion ці CVS, да якіх вы магчыма прывыклі. У Git гэта паказальнік на лякальную галіну, на якой вы знаходзіцеся. У дадзеным выпадку вы ўсё ячшэ на галіне master. Каманда git branch толькі стварыла новую галіну, але яна не пераключыла вас на яе (гл. Малюнак 3-5).

Insert 18333fig0305.png 
Малюнак 3-5. Файл HEAD паказвае на цякучую галіну.

Каб перайсьці на існуючую галіну, вам неабходна выканаць каманду `git checkout`. Давайце пяройдзем на новую галіну testing:

	$ git checkout testing

Гэтае дзеяньне перамяшчае HEAD так, каб той паказваў на галіну testing (гл. Малюнак 3-6)

Insert 18333fig0306.png
Малюнак 3-6. HEAD паказвае на іншую галіну, калі вы іх пераключаеце.

У чым важлівасьць гэтага дзеяньня? Давайце зробім ячшэ адзін каміт:

	$ vim test.rb
	$ git commit -a -m 'made a change'

На Малюнку 3-7 паказаны вынік.

Insert 18333fig0307.png 
Малюнак 3-7. Галіна, на якую паказвае HEAD, рухаецца ўперад з кожным камітам.

Гэта цікава, таму што цяпер вашая галіна testing перасунулася ўперад, але вашая галіна master усё ячшэ паказвае на каміт, на якім вы былі, калі выконвалі `git checkout`, каб пераключыць галіны. Давайце пяройдзем назад на галіну master:

	$ git checkout master

На Малюнку 3-8 можна пабачыць вынік.

Insert 18333fig0308.png 
Малюнак 3-8. HEAD перамяшчаецца на іншую галіну пры  checkout'е.

Гэтая каманда выканала два дзеяньні. Яна перасунула паказальнік HEAD назад на галіну master і вярнула файлы ў вашым працоўным каталёзе назад, у адпаведнасьці з здымкам стану, на які паказвае master. Гэта таксама азначае, што зьмены, якія вы робіце з гэтага моманту, будуць адгаліноўвацца ад старой вэрсіі праекта. Гэта цалкам адкочвае???? зьмены, якія вы часова рабілі на галіне testing. Такім чынам, далей вы можаце рухацца ў іншых накірунку.

Давайце зноў зробім трохі зьменаў і зафіксуем іх:

	$ vim test.rb
	$ git commit -a -m 'made other changes'

Цяпер гісторыя вашага праекту разгалінавалась (см. Малюнак 3-9). Вы стварылі новую галіну, перайшлі на яе, папрацавалі на ёй трохі, пераключыліся назад на асноўную галіну і выканалі новую працу. Абодвы гэтая зьмяненьні ізаляваныя на асобных галінах: вы можаце пераключыцца туды і назад паміж галінамі і зьміць іх, калі будзеце гатовы. І вы зрабілі ўсё гэта простымі камандамі `branch` і `checkout`.

Insert 18333fig0309.png 
Малюнак 3-9. Гісторыя з галінамі, якія разыйшліся.

З-за таго, што галіна ў Git на самой справе зьяўляецца простым файлам, які утрымлівае 40 сімвалаў кантрольнай сумы SHA-1 каміта, на які ён паказвае, стварэньне і выдаленьне галінаў практычна безвыдаткова. Стварыць новую галіну можна так жа хутка і проста, як запісаць 41 байт (40 сімвалаў??? + сімвал перахода на новы радок). 

Гэта адрозьніваецца ад таго, як у большасьці СКВ робіцца галінаваньне. Там гэта прыводзіць да капіяваньня ўсіх файлаў праекта у іншую тэчку. Гэта можа запатрабаваць некалькіх сякундаў ці нават хвілінаў, у залежнасьці ад памеру праекту, тады як у Git гэты працэс заўсёды імгненна. Таксама, з-за таго, што мы запамінаем продкаў для кожнага каміта, пошук неабходнай базавай вэрсіі для зьліцьця ўжо аўтаматычна выкананы за нас, і ўвогуле зьліцьцё робіцца лёгка. Гэтыя асаблівасьці дапамагаюць заахвочваць распрацоўнікаў да частага стварэньня і выкарыстаньня галінаў.

Давайце зразумеем, чаму вам неабходна так рабіць.

## Падставы галінаваньня і зьліцьця ##

Давайце разгледзім просты прыклад галінаваньня і зьліцьця з такім працэсам працы, які вы б маглі выкарыстаць у сапраўднай распрацоўцы. Вы будзеце рабіць наступнае:

1.	Працаваць з вэб-сайтам.
2.	Створыце галіну для новай гісторыі, над якой вы працуеце.
3.	Выканаеце нейкую працу на гэтай галіне.

На гэтым этапе вы атрымаеце атрымаеце сыгналь аб тым, што зараз маецца крытычная іншая праблема, і яе вам трэба тэрмінова вырашыць. Вы робіце наступнае:

1.	Вярнецеся на вытворучую галіну.
2.	Створыце галіну для выпраўленьня памылкі.
3.	Пасьля тэставаньня, зьліцё галіну з выпраўленьнем і абнавіце аддаленае сховішча.
4.	Пераключыцеся да перапыненай гісторыі і працягніце працу.

### Падставы галінаваньня ###

Для пачатку ўявім, што вы працуеце з сваім праектам і ўжо маеце некалькі камітаў (гл. Малюнак 3-10).

Insert 18333fig0310.png 
Малюнак 3-10. Кароткая і простая гісторыя камітаў.

Вы вырашылі, што будзеце працаваць над праблема №53 з сыстэмы адсочваньня памылак, якую выкарыстоўвае вашая кампанія. Зразумела, Git не прывязаны да якой-небудзь вызначанай сыстэмы адсочваньня памылак. Наўпрост з-за таго, што праблема №53 зьяўляецца асноўнай задачай, над якой вы хочыце працаваць, вы створыце новую галіну для працы зь ёй. Каб стварыць галіну і адразу перайсьці на яе, вы можаце выканаць каманду `git checkout` з ключом `-b`:

	$ git checkout -b iss53
	Switched to a new branch "iss53"

Гэта скарачэньне для:

	$ git branch iss53
	$ git checkout iss53

Малюнак 3-11 паказвае вынік.

Insert 18333fig0311.png 
Малюнак 3-11. Стварэньне новай галіны / паказальніка.

Пад час працы над вашым вэб-сайтам, вы робіце некалькі камітаў. Гэтыя дзеяньні перасоўваюць галіну `iss53` наперад таму, што вы на яе перайшлі (гэта значыць ваш HEAD паказвае на яе; гл. Малюнак 3-12):


	$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'

Insert 18333fig0312.png 
Малюнак 3-12. Галіна iss53 перасунулася наперад пад час працы.

Цяпер вы атрымаеце сыгналь аб тым, што ёсьць праблема з вэб-сайтам, якую неабходна хутка выправіць. З Git, ў вас няма патрэбы ствараць латку разам з тымі зьменамі, якія вы ўжо зрабілі для `iss53`. А таксама ня трэба прыкладваць шмат намаганьняў, каб адмяніць гэтыя зьмены перад тым, як вы зможаце пачаць працаваць над рашэньнем тэрміновай праблемы. Усё, што вам трэба зрабіць, гэта перайсьці на галіну master.

Аднак, перад тым як гэта зрабіць, майце на ўвазе, што калі ў вашай працэўной тэчцы ці індэксе маюцца незафіксаваныя зьмены, якія канфліктуюць з галіной, на якую вы пераходзіце, Git не дазволіць пераключыць галіны. Лепей за ўсё пры пераключэньні галінаў мець чысты працоўны стан. Існуе некалькі спосабаў дасягнуць гэтага (а менавіта, хаваць працу і правіць каміты), якія мы разгледзім пазьней. А на дадзены момант уявім, што вы зафіксавалі ўсе зьмены, і можаце пераключыцца назад на галіну master:

	$ git checkout master
	Switched to branch "master"

Цяпер працоўны каталёг праекту знаходзіцца ў тым жа стане, што і ў момант пачатку працы над праблемай №53, так што вы можаце сканцэнтравацца на хуткім зьмяненьні. Вельмі важліва запомніць: Git вяртае ваш працоўны каталёг да здымка стану таго каміта, на які паказвае галіна, на якую вы пераходзіце. Ён дабаўляе, выдаляе і зьмяняе файлы аўтаматычна, каб гарантаваць, што стан вашай працоўнай копіі ідэнтычнае апошняму каміту на галіне.

Так, вам трэба хутка выправіць памылку. Давайце створым для гэтага галіну, на якой вы будзеце працаваць (гл. Малюнак 3-13):


	$ git checkout -b 'hotfix'
	Switched to a new branch "hotfix"
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: "fixed the broken email address"
	 1 files changed, 0 insertions(+), 1 deletions(-)

Insert 18333fig0313.png 
Малюнак 3-13. Галіна для рашэньня тэрміновай праблемы базуецца на галіне master.

Вы можаце запусьціць тэсты, пераканацца, што рашэньне працуе, і зьліць зьмены назад на галіну master, каб уключыць яго ў сховішча. Гэта робіцца з дапамогай каманды `git merge`:

	$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)

Напэўна, вы заўважылі фразу "Fast forward" у гэтым зьліцьці. Так як галіна, якую вы зьлівалі, паказвала на каміт, які зьяўляецца прамым нашчадкам каміта, на якім вы знаходзіцеся, Git перасоўвае паказальнік наперад. Іншымі словамі, калі вы спрабуеце зьліць адзін каміт з іншым, які можа быць дасягнуты, калі вы ідзяце па гісторыі першага каміта, Git зпрашчае рэчы, перасоўваючы паказальнік наперад, так як няма разыходзячых зьменаў для зьліцьця іх у адно цэлае. Гэта называецца "fast forward" (перамотка).

Вашыя зьмены цяпер у здымку стану каміта, на які паказвае галіна master, і вы можаце ўключыць зьмены ў сховішча (гл. Малюнак 3-14).

Insert 18333fig0314.png 
Малюнак 3-14. Пасьля зьліцьця галіна master паказвае туды ж, куды і галіна hotfix.

Пасьля таго, як вельмі важлівая праблема вырашана, вы гатовыя вярнуцца назад да працы, якую рабілі, перад тым як былі перапынены. Аднак, спачатку выдаліце галіну `hotfix`, так як яна больш не патрэбна - галіна `master` ужо паказвае на тое ж месца. Вы можаце выдаліць галіну з дапамогай опцыі `-d` да `git branch`:

	$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).

Цяпер вы можаце вярнецца назад да працоўнай галіны для праблемы №53 і працягнуць працаваць зь ёй (см. Малюнак 3-15):

	$ git checkout iss53
	Switched to branch "iss53"
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: "finished the new footer [issue 53]"
	 1 files changed, 1 insertions(+), 0 deletions(-)

Insert 18333fig0315.png 
Малюнак 3-15. Каліна iss53 можа рухацца наперад незалежна.

Варта нагадаць, што праца, зробленая на галіне `hotfix`, не ўключана ў файлы на галіне `iss53`. Калі вам гэта неабходна, вы можаце выканаць зьліцьцё галіны `master` у галіну `iss53` з дапамогай каманды `git merge master`. Ці вы можаце пачакаць з інтэграцыяй зьменаў да той пары, пакуль не вырашылі ўключыць зьмены на `iss53` у галіну `master`.

### Падставы зьліцьця ###

Уявіце сабе, што вы разабралісь з праблемай №53 і гатовы аб'яднаць гэтую галіну і сваю `master`. Каб гэта зрабіць, вы выканайце зьліцьцё вашай галіны `iss53` у галіну `master` таксама так, як вы рабілі раней з галіной `hotfix`. Ўсё што вы павінны зрабіць - перайсьці на гэтую галіну, у якую вы хочаце ўнесьці свае зьмены і выканаць загад `git merge`:

	$ git checkout master
	$ git merge iss53
	Merge made by recursive.
	 README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)

Зараз зьліцьцё выглядае крышку ня так, як для галіны `hotfix`, якое вы рабілі раней. У дадзеным выпадку вашая гісторыя разпрацоўкі разьдзялілась у нейкай кропцы. Так як каміт на той галіне, на якой вы знаходзіцеся, не зьяўляецца прамым нашчадкам для галіну, якую вы зьліваеце, Git'у давядзецца зрабіць некаторую працу. У гэтым выпадку Git робіць простае троххадовае зьліцьцё, пры гэтым выкарыстоўвае два здымкі станаў сховішча, на якія паказваю верхавіны галінаў, і агульны здымак-прабацька!!! для гэтых двух галінаў. На малюнку 3-16 выдзелены тры здымкі, якія Git будзе выкарыстоўваць для зьліцьця ў гэтым выпадку.

Insert 18333fig0316.png
Малюнак 3-16. Git аўтаматычна вызначае найлепшага агульнага продак для зьвіцьця галінаў.

Замест таго, каб проста перасунуць паказальнік галіны наперад, Git стварае новы здымак стану, які зьяўляецца вынікам троххадовага зьліцьця, і аўтаматычна створыць новы каміт, які паказвае на гэты новы здымак стану (глядзі Малюнак 3-17). Такі каміт называюць каміт-зьліцьцё, так як ён зьяўляецца незвычайным з-за таго, што мае больш аднаго продак.

Варта адзначыць, што Git вызначае найлепшага агульнага продка для зьліцьця галінаў; у CVS ці Subversion (вэрсіі ранейшай за 1.5) гэтага не адбываецца. Разпрацоўнік павінен сам паказаць падставу для зьліцьця. Гэта робіць зьліцьцё у Git значна больш простым заняткам, чым у іншых сыстэмах.

Insert 18333fig0317.png
Малюнак 3-17. Git аўтаматычна стварае новы каміт, які ўтрымлівае вынікі зьліцьця.

Цяпер, калі вы ажыцьцявілі зьліцьцё вашых напрацовак, галіна `iss53` вам больш не патрэбна.Мажаце выдаліць яе і затым уручную закрыць картку(ticket) у вашай сыстэме: 

	$ git branch -d iss53

### Падставы канфліктаў пры зьліцьці ###

Часам працэс зьліцьця не ідзе гладка. Калі вы зьмянілі адну і тую ж частку файла па-рознаму ў дзьвух галінах, якія вы зьбіраецеся аб'яднаць, Git ня зможа зрабіць гэта чыста. Калі ваша рашэньне праблемы №53 зьмяняе тую ж частку файла, што і `hotfix`, вы атрымаеце канфлік зьліцьця, і выглядаць ён будзе прыкладна наступным чынам:

	$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.

Git не стварыў новы каміт для зьліцьця. Ён прыпыніў гэты працэс да той пары, пакуль вы ня вырашыце канфлікт. Калі вы хочаце паглядзець, якія файлы не прайшлі ў зьліцьцё (на гэтым этапе пасьля ўзьнікненьня канфлікта), можаце выканаць каманду `git status`:

	[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#   (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#	unmerged:   index.html
	#

Усё, што мае адносіны да канфлікту зьліцьця і што не было вырашана, адзначана як unmerged. Git дабаўляе стандартныя маркеры да файлаў, якія маюць канфлікт, так як вы можаце адкрыць іх уручную!!! і вырашыць гэтыя канфлікты. Ваш файл утрымлівае сэкцыю, якая выглядае прыкладна так:

	<<<<<<< HEAD:index.html
	<div id="footer">contact : email.support@github.com</div>
	=======
	<div id="footer">
	  please contact us at support@github.com
	</div>
	>>>>>>> iss53:index.html

У верхняй частцы блёка (усё што вышэй за `=======`) гэта вэрсія з HEAD (вашай галіны master, так як менавіта на яе вы перайшлі перад выкананьнем каманды merge), усё што знаходзіцца ў ніжняй частцы - вэрсія ў `iss53`. Каб вырашыць канфлікт вы павінны выбраць адну з гэтых частак, ці неяк аб'яднаць зьмест па свайму рашэньню. Напрыклад, вы можаце вырашыць гэты канфлікт заменай ўсяго блёка, паказанага вышэй, наступным блёкам:

	<div id="footer">
	please contact us at email.support@github.com
	</div>

Гэта рашэньне ўтрымлівае па трохі з кожнай часткі, і я цалкам выдаліў радкі `<<<<<<<`, `=======` і `>>>>>>>`. Пасьля гэтага, як вы вырашылі кожную з гэтых сэкцыяў з кожным канфліктным файлам, выканайце `git add` для кожнага кафліктнага файла. Індэксаваньне будзе азначаць для Git, што ўсе канфлікты ў файле цяпер вырашаныя.

Калі вы захочыце выкарыстаць графічныя прылады для вырашэньня канфліктаў, можаце выканаць загад `git mergetool`, які запусьціць адпаведны графічную прыладу і пакажа канфліктныя сытуацыі:

	$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html

	Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):

Калі вы можаце выкарыстаць іншую прыладу для зьліцьця, акрамя прадвызначанай (Git выбраў `opendiff` для мяне, так як я выканаў каманду на Mac). Вы можаце ўбачыць усе магчымыя прылады, паказаныя вышэй пасьля “merge tool candidates”. Пазначце назвы пажаданай для вас прылады. У *Главе 7* мы абмяркуем, як зьмяніць гэтае прадвызначанае значэньне для вашай сыстэмы.

Пасьля таго, як вы выйдзіце з прылады для выкананьня зьліцьця, Git спытае вас, было яно пасьпяховым ці не. Калі вы адказваеце, што так - файл індэксуецца (дадаецца ў вобласьць для каміта), каб даць вам зразумець, што канфлікт вырашаны.

Можаце выканаць `git status` ячшэ раз, каб пераканацца, што ўсе канфлікты былі вырашаныя:

	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	modified:   index.html
	#

Калі вы задаволеныя тым, што атрымалі, і пераканаліся, што ўсе канфлікты вырашаныя, файлы праіндэксаваныя, можаце выканаць `git commit` для завяршэньня зьліцьця. Прадвызначана паведамленьне каміта будзе выглядаць прыкладна так:

	Merge branch 'iss53'

	Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.
	# If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.
	#

Вы можаце дапоўніць гэтае паведамленьне інфармацыяй аб тым, як вы вырашылі канфлікт, калі лічаце, што гэта можа быць карысна для іншых у будучыні. Напрыклад, можаце паказаць чаму вы зрабілі тое, што зрабілі, калі гэта безумоўна не відавочна.

## Кіраваньне галінамі ##

Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками. Когда вы начнете постоянно использовать ветки, эти инструменты очень вам пригодятся.

Команда `git branch` делает несколько больше, чем просто создает и удаляет ветки. Если вы выполните ее без аргументов, то получите простой список ваших текущих веток:

	$ git branch
	  iss53
	* master
	  testing

Обратите внимание на символ `*`, стоящий перед веткой `master`: он указывает на ту ветку, на которой вы находитесь в настоящий момент. Это означает, что если вы сейчас выполните коммит, ветка `master` переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`:

	$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes

Другая полезная возможность для выяснения состояния ваших веток состоит в том, чтобы оставить в этом списке только те ветки, для которых вы выполнили (или не выполнили) слияние с веткой, на которой сейчас находитесь. Для этих целей в Git, начиная с версии 1.5.6, есть опции `--merged` и `--no-merged`. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду `git branch --merged`:

	$ git branch --merged
	  iss53
	* master

Так как вы уже выполняли слияние для ветки `iss53` ранее, вы видите ее в своем списке. Неплохой идеей было бы удалить командой `git branch -d` те ветки из этого списка, перед которыми нет символа `*`; вы уже объединили наработки из этих веток с другой веткой, так что вы ничего не теряете.

Чтобы посмотреть все ветки, содержащие наработки, которые вы еще не объединили с текущей веткой, выполните команду `git branch --no-merged`:

	$ git branch --no-merged
	  testing

Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить ее командой `git branch -d` не увенчается успехом:

	$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.
	If you are sure you want to delete it, run 'git branch -D testing'.

Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции `-D`, как указано в подсказке.

## Приемы работы с ветками ##

Теперь, когда вы познакомились с основами ветвления и слияния, что вам делать с ветками дальше? В этом разделе мы рассмотрим некоторые стандартные приёмы работы, которые становятся возможными, благодаря лёгкому осуществлению ветвления. И вы сможете выбрать, включить ли вам какие-то из них в свой цикл разработки.

### Долгоживущие ветки ###

Так как Git использует простое трехходовое слияние, сливать одну ветку с другой несколько в течение большого промежутка времени достаточно просто. Это значит вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать одну из них с другой.

Много разработчиков Git-а ведут свой рабочий процесс в соответствии с этой идеей. Например, стабильный код располагается только в ветке `master` ― единственный стабильный код, который был или будет выпущен. Они имеют другую параллельную ветку, называемую develop (разработка) или next (следующая), из которой они работают или используют для проверки на стабильность ― она не обязательно всегда стабильна, но когда она принимает стабильное состояние, можно слить её в `master`. Она используется чтобы включать в себя изменения от коротких веток (таких как ветка `iss53`, с которой вы имели дело ранее) когда они готовы, чтобы удостовериться, что они успешно проходят все тесты и не вызывают ошибок.

В действительности же, мы говорим об указателях, передвигающихся вверх по линии коммитов, которые вы делаете. Стабильные ветки далеко внизу линии вашей истории коммитов, наиболее свежие ветки находятся ближе к верхушке этой линии (смотри Рисунок 3-18).

Insert 18333fig0318.png 
Рисунок 3-18. Более стабильные ветки как правило находятся дальше в истории коммитов.

В общем, об этом проще думать как о силоснах башнях, где набор коммитов переходит в более стабильную башню только тогда, когда он полностью протестирован (смотри Рисунок 3-19).

Insert 18333fig0319.png 
Рисунок 3-19. Может быть полезным думать о ветках как о силосных башнях.

Вы можете применять эту идею для нескольких разных уровней стабильности. Некоторые большие проекты также имеют ветку `proposed` или `pu` (proposed updates ― предлагаемые изменения), которые включают в себя ветки, не готовые для перехода в ветку `next` или `master`. Идея такова, что ваши ветки находятся на разных уровнях стабильности; когда они достигают более высокого уровня стабильности, они сливаются с веткой, стоящей на более высоком уровне.
Опять-таки, не обязательно иметь долгоживущие ветки, но часто это очень полезно, особенно когда вы имеете дело с очень большими и сложными проектами.

### Тематические ветки ###

Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка ― недолговечная ветка, которую вы создаете и используете для некоторой отдельной возможности или вспомогательной работы. Это то, чего вы вероятно никогда не делали с системами управления версиями раньше, так как создание и слияние веток обычно слишком затратно. Но в Git принято создавать ветки, работать над ними, объединять и удалять их по несколько раз в день.

Вы видели подобное в последнем разделе, где вы создавали ветки `iss53` и `hotfix`. Вы сделали несколько коммитов на этих ветках и удалили их сразу после объединения с вашей основной веткой. Такая техника позволяет вам быстро и полноценно переключать контекст. Когда все изменения в данной ветке относятся к определённой теме, достаточно просто отслеживать, что происходило во время работы с кодом. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их с основной веткой, независимо от порядка, в котором их создавали или работали над ними.

Рассмотрим пример, когда выполняется некоторая работа (в ветке `master`), делается ответвление для решения проблемы (`iss91`), выполняется немного работы на ней, делается ответвление второй ветки для другого пути решения той же задачи (`iss91v2`), осуществляется переход назад на вашу основную ветку (`master`) и выполнение работы на ней, затем делается ответвление от неё для выполнения чего-то, в чём вы не уверены, что это хорошая идея (ветка `dumbidea`). Ваша история коммитов будет выглядеть примерно так как на Рисунке 3-20.

Insert 18333fig0320.png 
Рисунок 3-20. История коммитов с несколькими тематическими ветками.

Теперь представим, вы решили, что вам больше нравится второе решение для вашей задачи (`iss91v2`); и вы показываете ветку `dumbidea` вашим коллегам и оказывается, что она просто гениальна. Так что вы можете выбросить оригинальную ветку `iss91` (теряя при этом коммиты C5 и C6) и слить две другие. Тогда ваша история будет выглядеть как на Рисунке 3-21.

Insert 18333fig0321.png 
Рисунок 3-21. Ваша история после слияния dumbidea и iss91v2.

Важно запомнить, что когда вы выполняете все эти действия, ветки являются полностью локальными. Когда вы выполняете ветвление и слияние, всё происходит только в вашем репозитории ― связь с сервером не осуществляется.

## Удалённые ветки ##

Удалённые ветки ― это ссылки на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.

Они выглядят как `(имя удал. репоз.)/(ветка)`. Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, проверьте ветку `origin/master`. Если вы с партнёром работали над одной проблемой, и он выложил ветку `iss53`, у вас может быть своя локальная ветка `iss53`; но та ветка на сервере будет указывать на коммит в `origin/iss53`.

Всё это возможно сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас есть Git-сервер в сети на `git.ourcompany.com`. Если вы склонируете (clone) с него, Git автоматически назовёт его для вас `origin`, заберёт с него все данные, создаст указатель на его ветку `master` и назовёт его локально `origin/master` (но вы не можете его двигать). Git также сделает вам вашу собственную ветку `master`, которая будет начинаться там же, где и ветка `master` в origin, так что вам будет с чем начать работать (смотри Рис. 3-22).

Insert 18333fig0322.png 
Рисунок 3-22. Клонирование Git-проекта даёт вам собственную ветку master и origin/master указывающий на ветку master в origin.

Если вы сделаете что-то в вашей локальной ветке `master`, а тем временем кто-то ещё отправит (push) изменения на `git.ourcompany.com` и обновит там ветку master, то ваши истории продолжатся по-разному. К тому же, до тех пор, пока вы не свяжитесь с сервером origin, ваш указатель `origin/master` не будет сдвигаться (смотри Рисунок 3-23).

Insert 18333fig0323.png 
Рисунок 3-23. При выполнении локальной работы и отправке кем-то изменений на удалённый сервер, каждая история продолжается по-разному.

Для синхронизации вашей работы, выполняется команда `git fetch origin`. Эта команда ищет какому серверу соответствует origin (в нашем случае это `git.ourcompany.com`); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель `origin/master` на новую позицию (смотри Рисунок 3-24).

Insert 18333fig0324.png 
Рисунок 3-24. Команда git fetch обновляет ваши удалённые ссылки.

Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на `git.team1.ourcompany.com`. Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды `git remote add` так же как было описано в Главе 2. Дайте этому удалённому серверу имя `teamone`, которое будет сокращением для полного URL (смотри Рисунок 3-25).

Insert 18333fig0325.png 
Рисунок 3-25. Добавление дополнительного удалённого сервера.

Теперь можете выполнить `git fetch teamone`, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервер есть только часть данных, которые есть на сервере `origin`, Git не получает никаких данных, но выставляет удалённую ветку с именем `teamone/master`, которая указывает на тот же коммит, что и ветка `master` на сервере `teamone` (смотри Рисунок 3-26).

Insert 18333fig0326.png 
Рисунок 3-26. У вас появилась локальная ссылка на ветку master на teamone-е.

### Отправка изменений ###

Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами — вам нужно явно отправить те ветки, которыми вы хотите поделиться. Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.

Если у вас есть ветка `serverfix`, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же как вы отправляли вашу первую ветку. Выполните `git push (удал. сервер) (ветка)`:

	$ git push origin serverfix
	Counting objects: 20, done.
	Compressing objects: 100% (14/14), done.
	Writing objects: 100% (15/15), 1.74 KiB, done.
	Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -> serverfix

Это в некотором роде сокращение. Git автоматически разворачивает имя ветки `serverfix` до `refs/heads/serverfix:refs/heads/serverfix`, что означает “возьми мою локальную ветку serverfix и обнови из неё удалённую ветку serverfix”. Мы подробно обсудим часть с `refs/heads/` в Главе 9, но обычно можно её опустить. Вы можете сделать также `git push origin serverfix:serverfix`, что означает то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”. Можно использовать этот формат для отправки локальной ветки в удалённую ветку, которая называется по-другому. Если вы не хотите, чтобы ветка называлась `serverfix` на удалённом сервере, то вместо предыдущей команды выполните `git push origin serverfix:awesomebranch`. Так ваша локальная ветка `serverfix` отправится в ветку `awesomebranch` удалённого проекта.

В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает `serverfix` на сервере, как удалённую ветку `origin/serverfix`:

	$ git fetch origin
	remote: Counting objects: 20, done.
	remote: Compressing objects: 100% (14/14), done.
	remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.
	From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -> origin/serverfix

Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку `serverfix` — только указатель `origin/serverfix`, который вы не можете менять.

Чтобы слить эти наработки в вашу текущую рабочую ветку, можете выполнить `git merge origin/serverfix`. Если вы хотите иметь собственную ветку `serverfix`, над которой вы сможете работать, можете создать её на основе удалённой ветки:

	$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"

Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и `origin/serverfix`.

### Отслеживание веток ###

Получение локальной ветки с помощью `git checkout` из удалённой ветки автоматически создаёт то, что называется _отслеживаемой веткой_. Отслеживаемые ветки это локальные ветки, которые напрямую связаны с удалённой веткой. Если находясь на отслеживаемой ветке, вы наберёте `git push`, Git автоматически знает на какой сервер и в какую ветку отправлять изменения. Аналогично, выполнение `git pull` на одной из таких веток сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.

При клонировании репозитория, как правило, автоматически создаётся ветка `master`, которая отслеживает `origin/master`. Вот почему `git push` и `git pull` работают "из коробки" и не требуют других аргументов. Однако, если хотите, можете настроить другие отслеживаемые ветки — те, которые не отслеживают ветки в `origin`, и те, которые не отслеживают ветку `master`. Простой случай это тот пример, который вы только что видели — выполнение `git checkout -b [ветка] [удал. сервер]/[ветка]`. Если вы используете Git версии 1.6.2 или более позднюю, можете также воспользоваться сокращением `--track`:

	$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "serverfix"

Чтобы настроить локальную ветку с именем отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:

	$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.
	Switched to a new branch "sf"

Теперь ваша локальная ветка sf будет автоматически отправлять (push) и получать (pull) изменения из origin/serverfix.

### Удаление веток на удалённом сервере ###

Предположим, что вы закончили с удалённой веткой. Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку `master` на вашем удалённом сервере (или какую-то другую ветку, где у вас находится стабильный код). Вы можете удалить ветку на удалённом сервере используя весьма глупый синтаксис `git push [удал. сервер] :[ветка]`. Если вы хотите удалить ветку `serverfix` на сервере, выполните следующее:

	$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix

Хлоп. Нету больше ветки на вашем сервере. Вам может захотеться сделать закладку на текущей странице, так как эта команда вам понадобится, а синтаксис вы, скорее всего, забудете. Можно запомнить эту команду вернувшись к синтаксису `git push [удал. сервер] [лок. ветка]:[удал. ветка]`, который мы рассматривали немного раньше. Опуская часть `[лок. ветка]`, вы по сути говорите “возьми ничего у меня и сделай это `[удал. ветка]`”.

## Перемещение ##

В Git есть два способа включить изменения из одной ветки в другую: `merge` (слияние) и `rebase` (перемещение). В этом разделе вы узнаете, что такое перемещение, как его осуществлять, почему это удивительный инструмент и в каких случаях вам не следует его использовать.

### Основы перемещения ###

Если вы вернетесь назад к примеру из раздела Слияние (смотри Рисунок 3-27), вы увидите, что вы разделили вашу работу на два направления и выполняли коммиты на двух разных ветках.

Insert 18333fig0327.png
Рисунок 3-27. Впервые разделенная история коммитов.

Наиболее простое решение для объединения веток, как мы уже выяснили, команда `merge`. Эта команда выполняет трехходовое слияние между двумя последними снимками состояний из веток (C3 и C4) и последним общим предком этих двух веток (C2), создавая новый снимок состояния (и коммит), как показано на Рисунке 3-28.

Insert 18333fig0328.png
Рисунок 3-28. Слияние ветки для объединения разделившейся истории разработки.

Однако, есть и другой путь: вы можете взять изменения, представленные в C3, и применить их сверху C4. В Git это называется _перемещение_ (rebasing). При помощи команды `rebase` вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.

В этом примере вы выполните следующее:

	$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command

Это работает следующим образом: находится общий предок для двух веток (на которой вы находитесь сейчас и на которую вы выполняете перемещение); берётся разница, представленная в каждом из коммитов на текущей ветке, и сохраняется во временные файлы; текущая ветка устанавливается на такой же коммит, что и ветка, на которую вы выполняете перемещение; и, наконец, последовательно применяются все изменения. Рисунок 3-29 иллюстрирует этот процесс.

Insert 18333fig0329.png
Рисунок 3-29. Перемещение изменений, сделанных в C3, на C4.

На этом этапе можно переключиться на ветку master и выполнить слияние-перемотку (fast-forward merge) (смотри Рисунок 3-30).

Insert 18333fig0330.png
Рисунок 3-30. Перемотка ветки master.

Теперь снимок состояния, на который указывает C3, точно такой же, что тот, на который указывал C5 в примере со слиянием. Нет никакой разницы в конечном результате объединения, но перемещение выполняется для того, чтобы история была более аккуратной. Если вы посмотрите лог (log) перемещенной ветки, то увидите, что он выглядит как линейная история работы: выходит, что вся работа выполнялась последовательно, когда в действительности она выполнялась параллельно.

Часто вы будете делать это, чтобы удостовериться, что ваши коммиты правильно применяются для удаленных веток — возможно для проекта, владельцем которого вы не являетесь, но в который вы хотите внести свой вклад. В этом случае вы будете выполнять работу в ветке, а затем, когда будете готовы внести свои изменения в основной проект, выполните перемещение вашей работы на `origin/master`. Таким образом, владельцу проекта не придется делать никаких действий по объединению — просто перемотка (fast-forward) или чистое применение патчей.

Заметьте, что снимок состояния, на который указывает последний коммит, который у вас получился, является ли этот коммит последним перемещенным коммитом (для случая выполнения перемещения) или итоговым коммитом слияния (для случая выполнения слияния), есть один и тот же снимок — разной будет только история. Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.

### Более интересные перемещения ###

Вы также можете выполнять перемещение не только для перемещения ветки. Возьмём, например, историю разработки как на Рисунке 3-31. Вы создали тематическую ветку (`server`), чтобы добавить в проект некоторый функционал для серверной части, и сделали коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку server и сделали ещё несколько коммитов.

Insert 18333fig0331.png
Рисунок 3-31. История разработки с тематической веткой, ответвленной от другой тематической ветки.

Предположим, вы решили, что хотите внести ваши изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части, пока они не будут полностью протестированы. Вы можете взять изменения из ветки client, которых нет на server (C8 и C9), и применить их на ветке master при помощи опции `--onto` команды `git rebase`:

	$ git rebase --onto master server client

По сути, это указание “переключиться на ветку client, взять изменения от общего предка веток `client` и `server` и повторить их на `master`”. Это немного сложно; но результат, показанный на Рисунке 3-32, достаточно классный.

Insert 18333fig0332.png
Рисунок 3-32. Перемещение тематической ветки, ответвленной от другой тематической ветки.

Теперь вы можете выполнить перемотку (fast-forward) для вашей ветки master (смотри Рисунок 3-33):

	$ git checkout master
	$ git merge client

Insert 18333fig0333.png
Рисунок 3-33. Перемотка ветки master, чтобы включить изменения из ветки client.

Представим, что вы также решили включить ветку server в основную ветку. Вы можете выполнить перемещение ветки server на ветку master без предварительного переключения на эту ветку при помощи команды `git rebase [осн. ветка] [тем. ветка]` — которая устанавливает тематическую ветку (в данном случае `server`) как текущую и применяет её изменения на основной ветке (`master`):

	$ git rebase master server

Эта команда применит изменения из вашей работы над веткой `server` на вершину ветки `master`, как показано на Рисунке 3-34.

Insert 18333fig0334.png
Рисунок 3-34. Перемещение вашей ветки server на вершину ветки master.

Затем вы можете выполнить перемотку (fast-forward) основной ветки (`master`):

	$ git checkout master
	$ git merge server

Вы можете удалить ветки `client` и `server`, так как вся работа из них включена в основную линию разработки и они вам больше не нужны. При этом полная история вашего рабочего процесса выглядит как на Рисунке 3-35:

	$ git branch -d client
	$ git branch -d server

Insert 18333fig0335.png
Рисунок 3-35. Финальная история коммитов.

### Возможные риски перемещения ###

Все бы хорошо, но кое-что омрачает всю прелесть использования перемещения. Это выражается одной строчкой:

**Не перемещайте коммиты, которые вы выложили в публичный репозиторий.**

Если вы будете следовать этому указанию, все будет хорошо. Если нет — люди возненавидят вас, вас будут презирать ваши друзья и семья.

Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаете новые, которые являются похожими на старые, но в чем-то другими. Если вы выкладываете ваши коммиты куда-нибудь, и другие забирают их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой `git rebase` и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. Все запутается, когда вы в очередной раз попытаетесь включить их работу в свою.

Давайте рассмотрим пример того, как выполненное вами перемещение наработок, представленных для общего доступа, может вызвать проблемы. Представьте себе, что вы клонировали себе репозиторий с центрального сервера и поработали в нем. Ваша история коммитов выглядит как на Рисунке 3-36.

Insert 18333fig0336.png
Рисунок 3-36. Клонирование репозитория и выполнение в нём какой-то работы.

Теперь кто-то ещё выполняет работу, причём работа включает в себя и слияние, и отправляет свои изменения на центральный сервер. Вы извлекаете их и сливаете новую удалённую ветку со своей работой. Тогда ваша история выглядит как на Рисунке 3-37.

Insert 18333fig0337.png
Рисунок 3-37. Извлечение коммитов и слияние их со своей работой.

Далее, человек, выложивший изменения содержащие слияние, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет `git push --force`, чтобы переписать историю на сервере. Затем вы извлекаете изменения с этого сервера, включая и новые коммиты.

Insert 18333fig0338.png
Рисунок 3-38. Кто-то выложил перемещённые коммиты, отменяя коммиты, на которых вы основывали свою работу.

На этом этапе вы вынуждены объединить эту работу со своей снова, даже если вы уже сделали это ранее. Перемещение изменяет у этих коммитов SHA-1 хеши, так что для Git они выглядят как новые коммиты, тогда как на самом деле вы уже располагаете наработками C4 в вашей истории (смотри Рисунок 3-39).

Insert 18333fig0339.png
Рисунок 3-39. Вы снова выполняете слияние для той же самой работы в новый коммит слияния.

Вы вынуждены объединить эту работу со своей на каком-либо этапе, чтобы иметь возможность продолжать работать с другими разработчиками в будущем. После того, как вы сделаете это, ваша история коммитов будет содержать оба коммита — C4 и C4', которые имеют разные SHA-1 хеши , но представляют собой одинаковые изменения и имеют одинаковые сообщения. Если вы выполните команду `git log` когда ваша история выглядит таким образом, вы увидите два коммита, которые имеют одинакового автора и одни и те же сообщения. Это сбивает с толку. Более того, если вы отправите такую историю обратно на сервер, вы добавите все эти перемещенные коммиты в репозиторий центрального сервера, что может ещё больше запутать людей.

Если вы рассматриваете перемещение как возможность наведения порядка и работы с коммитами до того, как выложили их, и если вы перемещаете только коммиты, которые никогда не находились в публичном доступе — всё нормально. Если вы перемещаете коммиты, которые уже были представлены для общего доступа, и люди, возможно, основывали свою работу на этих коммитах, тогда вы можете получить наказание за разные неприятные проблемы.

## Итоги ##

Мы рассмотрели основы ветвления и слияния в Git. Вы должны чувствовать себя уверенно при создании и переходе на новые ветки, переключении между ветками и слиянии локальных веток. Вы также должны иметь возможность делиться своими ветками, выкладывая их на общий сервер, работать с другими людьми над общими ветками и перемещать свои ветки до того, как они были представлены для общего доступа.
