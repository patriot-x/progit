# Падставы Git #

Калі вы жадаеце пачаць працаваць з Git прачытаўшы толькі адну главу, то цяпер вы чытаеце тое, што вам патрэбна. Гэтая глава зьмяшчае асноўныя каманды, якія вам спатрэбяцца для працы з Git. Напрыканцы, вы будзеце мець магчымасьць наладжваць і ініцыялізаваць сховішча, пачынаць і спыняць адсочваньне файлаў, рыхтаваць і захоўваць зьмены. Таксама мы растлумачым як ігнараваць некаторыя файлы, хутка выпраўляць памылкі, сачыць за гісторыяй вашага праекту, адлюстроўваць зьмены паміж камітамі, дадаваць і сьцягваць зьмены з аддаленага сховішча.

## Стварэньне сховішча Git ##

Існуе два падыходы стварэньня сховішча Git. Першы — гэта імпартаваць існы праект ці тэчку ў Git. Другі — кланаваць існае сховішча Git зь іншага сэрвера.

### Ініцыялізацыя сховішча ў існай дырэкторыі ###

Каб пачаць адсочваць існы праект з дапамогаю Git, вам спачатку неабходна перайсьці ў тэчку праекта і ўвесьці каманду:

	$ git init

Яна створыць новую паддырэкторыю `.git`, якая ўтрымлівае ўсе неабходныя файлы сховішча — шкілет сховішча Git. На дадзены момант яшчэ ніводны з файлаў праекту не адсочваецца. (Больш дакладную інфармацыю якія менавіта файлы захоўваюцца ў толькі што створанай дырэкторыі `.git` глядзіце ў *Главе 9*).

Калі вы жадаеце пачаць кантраляваць існыя файлы праекту (за выняткам пустых тэчак), вам варта падрыхтаваць іх і зрабіць першы каміт. Вы можаце выканаць гэта некалькімі камандамі `git add`, якія падрыхтуюць неабходныя файлы, і затым `git commit`:

	$ git add *.c
	$ git add README
	$ git commit -m 'initial project version'

Мы разгледзім, што робяць гэтыя каманды крыху пазьней. А цяпер вы маеце сховішча Git з даданымі файламі і пачатковым камітам.

### Кланаваньне існага сховішча ###

Калі вы жадаеце атрымаць копію існага сховішча Git, напрыклад праекта, які вы хочаце падтрымаць, то вам спатрэбіцца каманда `git clone`. Калі вам вядомы іншыя сыстэмы кіраваньня вэрсіямі, напрыклад Subversion, то вы заўважыце, што каманда называецца `clone`, а не `checkout`. Гэта важлівае адрозьненьне — Git атрымлівае паўнавартасную копію зьвестак з сэрвера. Кожная вэрсія кожнага файла сьцягваецца ў ваша сховішча, калі выконваецца каманда `git clone`. Фактычна, калі ваш сэрверны дыск зламаецца, то з дапамогай любога лякальнага сховішча любога кліента можна вярнуць сэрвер у стан, у якім быў зроблены клон дадзенага сховішча (вы, магчыма, згубіце частку сэрверных хукаў, але ўсе зьвесткі, якія знаходзяцца пад вэрсійным кантролем, захаваюцца. Падрабязьней гл. у *Главе 4*).

Склануйце сховішча загадам `git clone [url]`. Напрыклад, калі вы жадаеце атрымаць клон бібліятэкі Ruby Git — Grit, то зрабіце гэта наступным чынам:

	$ git clone git://github.com/schacon/grit.git

Будзе створана дырэкторыя `grit`, ініцыялізавана паддырэкторыя `.git`, будуць сьцягнуты ўсе зьвесткі і створана працоўнуая копія праекту апошняй вэрсіі. Калі вы зойдзеце ў новую тэчку `grit`, пабачыце там файлы праекту зь якімі адразу можна працаваць. Калі жадаеце зрабіць клон у тэчцы зь іншым імем, то трэба пазначыць яго ў загадным радку:

	$ git clone git://github.com/schacon/grit.git mygrit

Гэтая каманда зробіць тое што й папярэдняя, але ў тэчцы `mygrit`.

Git можа працаваць зь некалькімі транспартнымі пратаколамі. Папярэдні прыклад выкарыстоўваў пратакол `git://`. Таксама вы можаце пабачыць пратакол `http(s)://` і `user@server:/path.git`, які карыстаецца SSH пратаколам. *Глава 4* распавядзе пра ўсе даступныя опцыі сэрвера для доступу да вашага Git-сховішча і прааналізуе плюсы й мінусы кожнага.

## Запіс зьменаў у сховішча ##

Урэшце, вы маеце дзейнае Git сховішча і працоўную тэчку з файламі праекту. У працэсе працы вам будзе неабходна зьмяняць файлы й фіксаваць іхныя „здымкі“ кожны раз, як праект будзе дасягаць патрэбнага вам стану.

Запомніце, кожны файл у вашай працоўнай тэчцы можа знаходзіцца ў адным з двух станаў: *адсочаны (tracked)* і *неадсочаны (untracked)*. Адсочаныя файлы — гэта файлы, якія былі захаваныя ў апошнім „здымку“ праекту. Яны, у сваю чаргу, могуць быць *немадыфікаванымі*, *мадыфікаванымі* й *падрыхтаванымі*. *Неадсочаныя* файлы — гэта ўсе астатнія файлы вашай працоўнай тэчкі. Іх няма ні ў апошніх „здымках“ праекту, ні сярод падрыхтаваных файлаў. Калі вы першы раз клануеце сховішча, усе ягоныя файлы будуць адсочанымі й немадыфікаванымі, бо вы толькі што зрабілі іх копію і не пасьпелі што-небудзь зьмяніць.

Як толькі вы адрэдагавалі файлы, Git пабачыць іх як мадыфікаваныя, таму што яны адрозьніваюцца ад файлаў у апошнім каміце. Вы мусіце *падрыхтаваць* гэтыя мадыфікаваныя файлы і затым закамітаваць усе вашы падрыхтаваныя зьмены, і гэты цыкл паўтараецца далей. Жыцьцёвы цыкл стану файла праілюстраваны на Малюнку 2-1.

Insert 18333fig0201.png
Малюнак 2-1. Жыцьцёвы цыкл стану вашых файлаў.

### Спраўджаньне стану вашых файлаў ###

Галоўным інструмэнтам, якім вы будзеце карыстацца для вызначэньня стану праекту, зьяўляецца каманда `git status`. Калі вы выканаеце гэтую каманду адразу пасьля кланаваньня праекту, то пабачыце прыкладна наступнае:

	$ git status
	# On branch master
	nothing to commit (working directory clean)

Гэта значыць, вы маеце чыстую працоўную дырэкторыю ці, іншымі словамі, вы ня маеце адсочаных мадыфікаваных файлаў. Git таксама ня бачыць неадсочаных файлаў, інакш яны былі б пералічаны тут. Нарэшце, каманда кажа ў якой галіне вы знаходзіцеся. Цяпер гэта галіна `master`, якая зьяўляецца прадвызначанай. Наступная глава распавядзе пра галіны й спасылкі больш падрабязна.

Давайце паглядзім што будзе, калі вы дадасьцё ў праект просты README файл. Калі гэты файл не існаваў да гэтага моманту, і вы выканаеце `git status`, вы ўбачыце ваш неадсочаны файл:

	$ vim README
	$ git status
	# On branch master
	# Untracked files:
	#   (use "git add <file>..." to include in what will be committed)
	#
	#	README
	nothing added to commit but untracked files present (use "git add" to track)

Вы можаце пабачыць, што Git ня сочыць за новым README файлам, бо ён знаходзіцца пад загалоўкам „Untracked files“ у вывадзе стану. Неадсочаны азначае тое, што Git знайшоў файл, які адсутнічаў у папярэднім „здымку“ (каміце). Git ня будзе ўключаць яго ў ваш новы каміт, пакуль вы самі яму ня мовіце зрабіць гэта. Гэта абараняе вас ад дадаваньня ў праект аўтаматычна створаных файлаў і іншых, якія вы не жадаеце дадаваць. Калі вы сапраўды жадаеце дадаць гэты файл у праект, то ён мусіць стаць адсочаным.

### Адсочваньне новых файлаў ###

Каб пачаць сачыць за файлам, трэба скарыстацца камандай `git add`. Для вышэй узгаданага README файла выканайце:

	$ git add README

Калі вы запусьціце каманду статусу зноў, вы пабачыце ваш README файл у сьпісе адсочаных і падрыхтаваных файлаў:

	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#

Цяпер можна сказаць, што гэта падрыхтаваны файл, бо ён знаходзіцца пад загалоўкам „Changes to be committed“. Калі вы зробіце каміт у дадзены момант, вы захаваеце вэрсію файла, якая была ў момант выкананьня каманды `git add`. Як вы памятаеце, пасьля каманды `git init` вы запусьцілі `git add (files)` і тым самым пачалі адсочваць файлы ў дырэкторыі праекту. Каманда `git add` прымае шлях да файла ці тэчкі; калі зададзена тэчка, то каманда рэкурсыўна дадае ўсе ўнутраныя файлы.

### Рыхтаваньне мадыфікаваных файлаў ###

Давайце зьменім які-небудзь адсочаны файл. Калі вы зьменіце раней дададзены файл `benchmarks.rb` і зноў выканаеце `git status`, вы атрымаеце нешта накшталт наступнага вываду:

	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#
	#	modified:   benchmarks.rb
	#

Файл `benchmarks.rb` зьявіўся под загалоўкам „Changed but not updated“. Гэта значыць, што гэта мадыфікаваны адсочаны файл, які не знаходзіцца ў прасторы рыхтаваньня. Каб падрыхтаваць яго, выканайце `git add` (гэта шматфункцыянальная каманда, якая выкарыстоўваецца для даданьня новых файлаў у праект, іх рыхтаваньня і для іншых мэтаў, напрыклад адзначэньне файлаў з вырашанымі канфліктамі аб’яднаньня). Давайце запусьцім `git add`, каб падрыхтаваць яго, і паглядзім на вывад `git status`:

	$ git add benchmarks.rb
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#	modified:   benchmarks.rb
	#

Абодва адлюстраваныя файлы падрыхтаваныя і будуць дададзеныя ў сховішча ў наступным каміце. Уявіце, што ў гэты момант вы ўспомнілі пра адну маленькую праўку, якую вам патрэбна зрабіць перад тым як закамітаваць зьмены. Вы адчыняеце файл, робіце й захоўваеце неабходныя праўкі і, здаецца, усё падрыхтавана для новага каміту. Але давайце яшчэ раз запусьцім `git status`:

	$ vim benchmarks.rb
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#	modified:   benchmarks.rb
	#
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#
	#	modified:   benchmarks.rb
	#

Якога д’ябла? Цяпер `benchmarks.rb` знаходзіцца і ў падрыхтаванай, і не ў падрыхтаванай прасторы. Як гэта магчыма? Гэта даказвае тое, што Git рыхтуе файлы толькі пасьля таго, калі вы выканаеце `git add`. Калі ўжыць каміт цяпер, то ў ім захаваецца вэрсія файла `benchmarks.rb`, якая была ў час апошняга запуску `git add`, а не `git commit`. Калі вы зьмянілі файл пасьля выкананьня каманды `git add`, то вы павінны выканаць яе зноў, каб падрыхтаваць апошнюю вэрсію файла:

	$ git add benchmarks.rb
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#	modified:   benchmarks.rb
	#

### Ігнараваньне файлаў ###

Часта, ваш праект будзе мець шэраг файлаў, якія вы ня толькі не захочаце аўтаматычна дадаваць у сховішча, але й бачыць іх сярод неадсочаных. Гэта могуць быць аўтаматычна спароджаныя файлы, як log-файлы ці файлы створаныя вашай сыстэмай збудаваньня. У гэтым выпадку, вы можаце стварыць файл `.gitignore`, які будзе ўтрымліваць сьпіс шаблёнаў файлаў, якія будуць ігнаравацца ў вашым праекце. Вось прыклад такога файла:

	$ cat .gitignore
	*.[oa]
	*~

Першы радок кажа Git’у ігнараваць усе файлы, якія сканчаюцца на `.o` ці `.a` — *аб’ектныя* і *архіўныя (бібліятэкі)* файлы, якія генэруюцца паводле зборкі вашага праекту. Другі радок кажа ігнараваць усе файлы, якія сканчаюцца на сымбаль `~`, што пазначае часовыя файлы, якія ствараюць мноства тэкставых рэдактараў кшталту Emacs. Вы таксама можаце ўключыць дырэкторыі `log`, `tmp` і `pid`, аўтаматычна створаную дакумэнтацыю і г.д. Дадаць файлы `.gitignore` у праект да пачатку асноўнай работы — вельмі добрая ідэя, бо такім чынам вы гарантуеце, што не закаміціце файлы, якія вы не жадаеце дадаваць у ваша git-сховішча.

Далей пералічаны правілы напісаньня шаблёнаў у файлах `.gitignore`:

*	Пустыя радкі й радкі, якія пачынаюцца з `#`, ігнаруюцца.
*	Можна выкарыстоўваць стандартныя glob шаблёны.
*	Можна завяршаць шаблён слэшам `/`, каб пазначыць дырэкторыю.
*	Можна інвэртаваць шаблён, калі прапісаць ў пачатку клічнік (`!`).

Glob шаблёны — гэта аналяг сталых выразаў, якія выкарыстоўваюць абалонкі. Зорачка (`*`) адпавядае любой колькасьці любых сымбаляў; `[abc]` — любому сымбалю, які знаходзіцца ў дужках (у дадзеным выпадку `a`, `b` ці `c`); пытальнік (`?`) — любому адзінаму сымбалю; дужкі, якія агароджваюць два сымбалі падзеленыя злучком (`[0-9]`), — любому сымбалю з гэтага дыяпазону.

Вось яшчэ некалькі прыкладаў радкоў з `.gitignore` файла:

	# камэнтар будзе праігнараваны
	*.a       # ігнараваць `.a`-файлы
	!lib.a    # за выняткам файла lib.a
	/TODO     # ігнараваць файл TODO толькі ў каранёвай тэчцы
	build/    # ігнараваць усе файлы ў дырэкторыі build/
	doc/*.txt # ігнараваць файлы кшталту doc/notes.txt, але ня doc/server/arch.txt

### Прагляд падрыхтаваных і непадрыхтаваных зьменаў ###

Калі загад `git status` вельмі недасканалы для вас, і вам неабходна ведаць якія менавіта зьмены адбыліся, а ня толькі ў якіх файлах яны адбыліся, то вы маеце скарыстацца камандай `git diff`. Больш падрабязна пра `git diff` мы распавядзем пазьней, а зараз, хутчэй за ўсё, вы будзеце выкарыстоўваць яе для атрыманьня адказу на два пытаньні: Што вы зьмянілі, але яшчэ не падрыхтавалі? і Што вы падрыхтавалі і зьбіраецеся зафіксаваць? Калі `git status` адказвае на гэтыя пытаньні вельмі абагульнена, то `git diff` адлюстроўвае вам паасобку кожны дададзены й выдалены радок — латку (patch), як яна ёсьць.

Уявім, вы зноў зьмянілі і падрыхтавалі файл `README`, а затым зьмянілі файл `benchmarks.rb`. Калі вы запусьціце `git status`, вы зноўку пабачыце нешта падобнае на гэта:

	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#	new file:   README
	#
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#
	#	modified:   benchmarks.rb
	#

Каб убачыць што менавіта было зьменена й не падрыхтавана, надрукуйце `git diff` без аргумэнтаў:

	$ git diff
	diff --git a/benchmarks.rb b/benchmarks.rb
	index 3cb747f..da65585 100644
	--- a/benchmarks.rb
	+++ b/benchmarks.rb
	@@ -36,6 +36,10 @@ def main
	           @commit.parents[0].parents[0].parents[0]
	         end

	+        run_code(x, 'commits 1') do
	+          git.commits.size
	+        end
	+
	         run_code(x, 'commits 2') do
	           log = git.commits('master', 15)
	           log.size

Гэтая каманда параўноўвае зьмест вашай працоўнай дырэкторыі са зьместам прасторы рыхтаваньня. Вынік адлюстроўвае непадрыхтаваныя зьмены.

Калі вы жадаеце ўбачыць падрыхтаваныя зьмены, якія будуць дададзеныя ў наступным каміце, вы павінны выканаць `git diff --cached` (у Git 1.6.1 і вышэй вы можаце выканаць загад `git diff --staged`, які прасьцейшы для запамінаньня). Гэтая каманда параўноўвае падрыхтаваныя зьвесткі і апошні каміт:

	$ git diff --cached
	diff --git a/README b/README
	new file mode 100644
	index 0000000..03902a1
	--- /dev/null
	+++ b/README2
	@@ -0,0 +1,5 @@
	+grit
	+ by Tom Preston-Werner, Chris Wanstrath
	+ http://github.com/mojombo/grit
	+
	+Grit is a Ruby library for extracting information from a Git repository

Заўважце, што `git diff` сам не адлюструе ўсіх зьменаў зробленых вамі пасьля апошняга каміту — толькі зьмены, якія застаюцца непадрыхтаванымі. Гэта можа заблытаць, бо калі вы ўсё падрыхтавалі, `git diff` нічога не пакажа ў вывадзе.

Іншы прыклад. Вы падрыхтавалі файл `benchmarks.rb` і потым адрэдагавалі яго. Вы можаце выканаць `git diff`, каб убачыць падрыхтаваныя зьмены і зьмены непадрыхтаваныя:

	$ git add benchmarks.rb
	$ echo '# test line' >> benchmarks.rb
	$ git status
	# On branch master
	#
	# Changes to be committed:
	#
	#	modified:   benchmarks.rb
	#
	# Changed but not updated:
	#
	#	modified:   benchmarks.rb
	#

Цяпер выканайце `git diff`, каб убачыць непадрыхтаваныя зьмены:

	$ git diff
	diff --git a/benchmarks.rb b/benchmarks.rb
	index e445e28..86b2f7c 100644
	--- a/benchmarks.rb
	+++ b/benchmarks.rb
	@@ -127,3 +127,4 @@ end
	 main()

	 ##pp Grit::GitRuby.cache_client.stats
	+# test line

і `git diff --cached` для падрыхтаваных:

	$ git diff --cached
	diff --git a/benchmarks.rb b/benchmarks.rb
	index 3cb747f..e445e28 100644
	--- a/benchmarks.rb
	+++ b/benchmarks.rb
	@@ -36,6 +36,10 @@ def main
	          @commit.parents[0].parents[0].parents[0]
	        end

	+        run_code(x, 'commits 1') do
	+          git.commits.size
	+        end
	+
	        run_code(x, 'commits 2') do
	          log = git.commits('master', 15)
	          log.size

### Фіксацыя зьменаў ###

Цяпер, калі ваша прастора рыхтаваньня не пустая, вы можаце закамітаваць вашы зьмены. Запомніце, усё што засталося непадрыхтаваным — любыя файлы, якія вы стварылі ці мадыфікавалі пасьля запуску `git add` — ня будзе ўключана ў каміт. Яны застануцца пазначанымі як мадыфікаваныя файлы на вашым дыску.
У нашым выпадку, паводле апошняга запуску `git status`, вы бачылі што ўсе файлы былі падрыхтаваныя, таму вы гатовы да прыманьня вашага каміту. Самы просты шлях зрабіць — гэта выканаць `git commit`:

	$ git commit

Дадзеная каманда запусьціць ваш тэкставы рэдактар (ён вызначаецца зьменнай асяродзьдзя `$EDITOR` — звычайна гэта vim ці emacs, але вы можаце ўсталяваць яго па свайму густу выкарыстаўшы каманду `git config --global core.editor`, як гэта апісана ў *Главе 1*).

Рэдактар адлюструе наступны тэкст (гэта прыклад зь Vim’а):

	# Please enter the commit message for your changes. Lines starting
	# with '#' will be ignored, and an empty message aborts the commit.
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       new file:   README
	#       modified:   benchmarks.rb
	~
	~
	~
	".git/COMMIT_EDITMSG" 10L, 283C

Вы бачыце, што прадвызначана каміт утрымлівае закамэнтаваны вывад каманды `git status` і адзін пусты радок зьверху. Можна выдаліць гэты камэнтар і напісаць сваё паведамленьне, ці пакінуць яго для ўзгадваньня дзе былі зроблены зьмены. Для яшчэ большай інфармацыі пра зьмены, вы можаце дадаць опцыю `-v` камандзе `git commit`. У выніку ў камэнтарах будзе прысутнічаць вывад каманды `git diff`, і вы будзеце дакладна ведаць што вы зрабілі. Калі вы пакініце рэдактар, Git створыць каміт з вашым паведамленьнем (камэнтар будзе адсутнічаць).

Як варыянт, вы можаце надрукаваць ваша паведамленьне ў загадным радку каманды `commit` пасьля опцыі `-m`:

	$ git commit -m "Story 182: Fix benchmarks for speed"
	[master]: created 463dc4f: "Fix benchmarks for speed"
	 2 files changed, 3 insertions(+), 0 deletions(-)
	 create mode 100644 README

Вось цяпер вы стварылі свой першы каміт! Вывад каманды дае неабходную інфармацыю пра яго: галіну, у якой ён захаваны (`master`); кантрольную суму SHA-1 (`463dc4f`); колькасьць зьмененых файлаў; статыстыку дадаваньня й выдаленьня радкоў.

Запомніце, што каміт запісвае здымак стану праекту, які вы захавалі ў прасторы рыхтаваньня. Усё што не было падрыхтавана так і застанецца ў мадыфікаваным стане. Вы можаце захаваць усё астатняе ў іншым каміце. Кожны раз, калі вы захоўваеце каміт, вы робіце здымак стану праекту, да якога вы зможаце вярнуцца пазьней, ці параўноўваць зь ім бягучы стан праекту.

### Мінаем прастору рыхтаваньня ###

Ня гледзячы на тое, што рыхтаваньне можа быць надзвычай карысным для стварэньня камітаў, але часам яно дадае больш складанасьцяў у працэс распрацоўваньня. Калі вы жадаеце абмінуць сыстэму рыхтаваньня, то Git прапануе вам просты спосаб зрабіць гэта. Дадаўшы опцыю `-a` да каманды `git commit`, вы загадваеце Git’у аўтаматычна падрыхтаваць усе адсочаныя файлы й закамітаваць іх. Давайце зробім каміт без рыхтаваньня:

	$ git status
	# On branch master
	#
	# Changed but not updated:
	#
	#	modified:   benchmarks.rb
	#
	$ git commit -a -m 'added new benchmarks'
	[master 83e38c7] added new benchmarks
	 1 files changed, 5 insertions(+), 0 deletions(-)

Заўважце, што на гэты раз вам не спатрэбілася запускаць `git add` для файла `benchmarks.rb` перад камітаваньнем.

### Выдаленьне файлаў ###

Каб выдаліць файл з Git, вам неабходна выдаліць яго са сьпісу адсочаных файлаў (дакладней, выдаліць яго з прасторы рыхтаваньня) і зрабіць каміт. Каманда `git rm` зробіць гэта ды яшчэ выдаліць файл з вашай працоўнай тэчкі, і наступны раз вы яго ня ўбачыце як неадсочаны.

Калі вы проста выдаліце файл з працоўнай тэчкі, то пасьля запуску `git status` вы ўбачыце яго ў разьдзеле „Changed but not updated (Зьмененыя, але не абноўленыя)“ (то бок *непадрыхтаваны*):

	$ rm grit.gemspec
	$ git status
	# On branch master
	#
	# Changed but not updated:
	#   (use "git add/rm <file>..." to update what will be committed)
	#
	#       deleted:    grit.gemspec
	#

Далей, калі вы выканаеце `git rm`, Git пазначыць яго як выдаленага:

	$ git rm grit.gemspec
	rm 'grit.gemspec'
	$ git status
	# On branch master
	#
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       deleted:    grit.gemspec
	#

Пасьля наступнага каміту, файл больш ня будзе адсочвацца. Калі вы ўжо зьмянілі файл і падрыхтавалі яго, то каб Git выдаліў яго, неабходна выканаць прымусовае выдаленьне з опцыяй `-f`. Гэта зроблена, каб прадухіліць выпадковае выдаленьне зьвестак, якія былі зьмененыя і не захаваныя ў сховішчы.

Другая карысная рэч якую вы можаце захацець зрабіць — гэта выдаліць файл з прасторы рыхтаваньня, але пакінуць яго ў працоўнай дырэкторыі. Іншымі словамі, вы жадаеце пакінуць файл на вашым жорсткім дыску, але Git не павінен больш сачыць за ім. Гэта можа спатрэбіцца, калі вы забылі нешта прапісаць у файл `.gitignore` і выпадкова падрыхтавалі непатрэбны файл, як вялікі log-файл ці пакунак `.a`-файлаў. У такіх выпадках трэба скарыстацца опцыяй `--cached`:

	$ git rm --cached readme.txt

Для `git rm` вы можаце пазначыць файлы, дырэкторыі ці glob-шаблёны. Такім чынам вы маеце магчымасьць прапісаць нешта кшталту:

	$ git rm log/\*.log

Зьвярніце ўвагу, што перад зорачкай `*` стаіць адваротны слэш `\`. Гэта неабходна, таму што Git выкарыстоўвае сваё пашырэньне для апрацоўкі шаблёнаў імёнаў файлаў. Гэтая каманда выдаліць усе файлы, якія маюць пашырэньне `.log` у тэчцы `log/`. Ці вы можаце напісаць нешта наступнае:

	$ git rm \*~

Гэтая каманда выдаляе ўсе файлы, якія сканчваюцца на `~`.

### Перамяшчэньне файлаў ###

У адрозьненьні ад іншых сыстэм кіраваньня вэрсіямі, Git непасрэдна не падтрымлівае перамяшчэньне файлаў. Калі вы пераймянуеце файл, у Git’е не захаваецца аніякіх мэтазьвестак пра тое, што вы яго перайменавалі. Аднак, Git дастаткова разумны, каб вызначыць ужо зьдзейсьнены факт перайменаваньня — перамяшчэньне файлаў мы разглядзім крыху пазьней.

Такім чынам, наяўнасьць каманды Git `mv` можа трохі заблытаць. Калі вы жадаеце перайменаваць файл у Git, вы мусіце выканаць наступнае:

	$ git mv file_from file_to

І гэта будзе выдатна працаваць. Калі вы сапраўды выканаеце гэта, і паглядзіце на стан сховішча, вы ўбачыце, што Git улічвае перайменаваньне файла:

	$ git mv README.txt README
	$ git status
	# On branch master
	# Your branch is ahead of 'origin/master' by 1 commit.
	#
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       renamed:    README.txt -> README
	#

Аднак, гэта ўсё эквівалентна наступным дзеяньням:

	$ mv README.txt README
	$ git rm README.txt
	$ git add README

Git няяўна высьвятляе што было перайменавана, таму ня мае значэньня так ці з дапамогай каманды `mv` вы перайменавалі файл. Сапраўдная розьніца паміж гэтымі шляхамі, што `mv` — гэта каманда, якая замяняе тры — функцыя для зручнасьці. Больш важна тое, што вы можаце выкарыстоўваць любы спосаб перайменаваньня файлаў, і перад камітаваньнем выкарыстаць `add/rm`.

## Прагляд гісторыі камітаў ##

Пасьля таго як вы зрабілі некалькі камітаў, ці атрымалі клон сховішча з існай гісторыяй камітаў, вы магчыма захочаце ўбачыць што было зроблена ў праекце да гэтага часу. Самым асноўным і карысным інструмэнтам для гэтага зьяўляецца `git log`.

Наступныя прыклады выкарыстоўваюць вельмі просты праект, які называецца `simplegit`. Яго я часта выкарыстоўваю для дэманстрацыі. Каб атрымаць яго выканайце 

	git clone git://github.com/schacon/simplegit-progit.git

Калі ў гэтым прекце вы запусьціце `git log`, вывад будзе выглядаць прыкладна так:

	$ git log
	commit ca82a6dff817ec66f44342007202690a93763949
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Mar 17 21:52:11 2008 -0700

	    changed the version number

	commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sat Mar 15 16:40:33 2008 -0700

	    removed unnecessary test code

	commit a11bef06a3f659402fe7563abf99ad00de2209e6
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sat Mar 15 10:31:28 2008 -0700

	    first commit

Прадвызначана, без аргумэнтаў, `git log` адлюстроўвае сьпіс зробленых камітаў у адваротным храналягічным парадку. Гэта значыць, што самыя апошнія каміты бачны першымі. Як вы заўважылі, кожны каміт утрымлівае ягоную кантрольную суму SHA-1, імя і электронную пошту аўтара, дату захаваньня, і паведамленьне.

Вялікая колькасьць і разнастайнасьць опцыяў каманды `git log` дазваляе дакладна вызначаць вывад, які вы жадаеце ўбачыць. Зараз мы вам распавядзём пра некаторыя найбольш ужывальныя зь іх.

Адна з самых карысных опцыяў — гэта `-p`, якая паказвае diff-паведамленьне для кожнага каміту. Вы таксама можаце дадаць опцыю `-2`, якая абмяжуе вывад апошнімі дзьвюма камітамі:

	$ git log -p -2
	commit ca82a6dff817ec66f44342007202690a93763949
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Mar 17 21:52:11 2008 -0700

	    changed the version number

	diff --git a/Rakefile b/Rakefile
	index a874b73..8f94139 100644
	--- a/Rakefile
	+++ b/Rakefile
	@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
	 spec = Gem::Specification.new do |s|
	-    s.version   =   "0.1.0"
	+    s.version   =   "0.1.1"
	     s.author    =   "Scott Chacon"

	commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sat Mar 15 16:40:33 2008 -0700

	    removed unnecessary test code

	diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index a0a60ae..47c6340 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -18,8 +18,3 @@ class SimpleGit
	     end

	 end
	-
	-if $0 == __FILE__
	-  git = SimpleGit.new
	-  puts git.show
	-end
	\ No newline at end of file

Дадзеная опцыя адлюстроўвае тую ж інфармацыю, але разам з зробленымі зьменамі пад кожным элемэнтам сьпісу. Гэта вельмі зручны рэжым для агляду коду ці для неабходнасьці хутка зразумець, якія зьмены зрабіў ваш супрацоўнік.
Таксама разам зь `git log` вы можаце выкарыстоўваць опцыі з групы абагульняючых парамэтраў. Напрыклад, калі вы жадаеце ўбачыць кароткую статыстыку па кожнаму каміту, вы мусіце дадаць опцыю `--stat`:

	$ git log --stat
	commit ca82a6dff817ec66f44342007202690a93763949
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Mar 17 21:52:11 2008 -0700

	    changed the version number

	 Rakefile |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)

	commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sat Mar 15 16:40:33 2008 -0700

	    removed unnecessary test code

	 lib/simplegit.rb |    5 -----
	 1 files changed, 0 insertions(+), 5 deletions(-)

	commit a11bef06a3f659402fe7563abf99ad00de2209e6
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sat Mar 15 10:31:28 2008 -0700

	    first commit

	 README           |    6 ++++++
	 Rakefile         |   23 +++++++++++++++++++++++
	 lib/simplegit.rb |   25 +++++++++++++++++++++++++
	 3 files changed, 54 insertions(+), 0 deletions(-)

Як вы бачыце, опцыя `--stat` друкуе пад кожным камітам сьпіс мадыфікаваных файлаў, іх колькасьці і колькасьць радкоў дададзеных і выдаленых. А ў канцы абагульняльная інфармацыя пра ўсе зьмены.
Другая сапраўды карысная опцыя — `--pretty`. Гэта опцыя зьмяняе фармат вываду. Даступна некалькі перадусталяваных варыянтаў. `oneline` друкуе кожны каміт адным радком, што можа быць зручна, калі вы праглядаеце шмат камітаў. У дадатак да гэтага ёсьць опцыі `short`, `full` і `fuller`, якія, практычна не зьмяняючы фармат, выводзяць менш ці больш інфармацыі адпаведна:

	$ git log --pretty=oneline
	ca82a6dff817ec66f44342007202690a93763949 changed the version number
	085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
	a11bef06a3f659402fe7563abf99ad00de2209e6 first commit

Найбольш цікавая опцыя — `format`, якая дазваляе вызначаць фармат вываду журнала. Яна асабліва карысна, калі вам неабходна генэраваць вывад для далейшага машыннага разбору — вы можаце дакладна вызначыць фармат і быць упэўненымі, што ён ня зьменіцца пасьля абнаўленьня Git.

	$ git log --pretty=format:"%h - %an, %ar : %s"
	ca82a6d - Scott Chacon, 11 months ago : changed the version number
	085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
	a11bef0 - Scott Chacon, 11 months ago : first commit

Табліца 2-1 зьмяшчае сьпіс некалькіх найбольш ужывальных опцыяў для ўсталяваньня фармату.

	Опцыя	Апісаньне вываду
	%H	Хэш каміту
	%h	Скарочаны хэш каміту
	%T	Хэш дрэва
	%t	Скарочаны хэш дрэва
	%P	Бацькоўскія хэшы
	%p	Скарочаныя бацькоўскія хэшы
	%an	Імя аўтара
	%ae	Электронная пошта аўтара
	%ad	Дата аўтара (фармат вызначаецца --date= )
	%ar	Дата аўтара, адносная
	%cn	Імя камітэра
	%ce	Электронная пошта камітэра
	%cd	Дата камітэра
	%cr	Дата камітэра, адносная
	%s	Паведамленьне

Вас напэўна зацікавіла ў чым розьніца паміж _аўтарам_ і _камітэрам_. _Аўтар_ — гэта асоба, якая напісала латку, а _камітэр_ — гэта той, хто ўжыў яе да праекту. Таму, калі вы адаслалі аднаму з распрацоўнікаў праекту сваю латку, то і ягонае, і вашае імя будзе ў каміце: ягонае — як камітэра, вашае — як аўтара. Больш падрабязна разгледзім гэта у *Главе 5*.

Опцыі `oneline` і `format` асабліва карысныя для іншай опцыі каманды `log` — `--graph`. Гэта опцыя просты ASCII-граф, які адлюстроўвае галіны і аб’яднаньні ў гісторыі. Яго вы можаце пабачыць у вашай копіі сховішча Grit:

	$ git log --pretty=format:"%h %s" --graph
	* 2d3acf9 ignore errors from SIGCHLD on trap
	*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
	|\
	| * 420eac9 Added a method for getting the current branch.
	* | 30e367c timeout code and tests
	* | 5a09431 add timeout protection to grit
	* | e1193f8 support for heads with slashes in them
	|/
	* d6016bc require time for xmlschema
	*  11d191e Merge branch 'defunkt' into local

Мы разглядзелі толькі самыя простыя опцыі для фармаваньня вываду `git log`, але іх значна больш. Табліца 2-2 зьмяшчае больш поўны сьпіс разам з апісаньнем узьдзеяньня на вывад.

	Опцыя	Апісаньне
	-p	Адлюстроўвае латку ўнесеную кожным камітам.
	--stat	Адлюстроўвае статыстыку мадыфікацыі файлаў кожнага каміту.
	--shortstat	Выводзіць толькі колькасьць зьмененых/дададзеных/выдаленых радкоў з опцыі --stat.
	--name-only	Адлюстроўвае сьпіс мадыфікаваных файлаў пасьля кожнага каміту.
	--name-status	Адлюстроўвае сьпіс файлаў разам зь інфармацыяй пра даданьне/мадыфікацыю/выдаленьне.
	--abbrev-commit	Адлюстроўвае толькі некалькі першых знакаў з кантрольнай сумы SHA-1 каміту (усе займаюць 40).
	--relative-date	Адлюстроўвае дату ў адносным фармаце (напрыклад, „2 тыдні назад“) замест паўнавартаснай формы.
	--graph	Адлюстроўвае ASCII-граф галін і аб’яднаньняў у гісторыі праекту ў вывадзе.
	--pretty	Адлюстроўвае каміт у альтэрнатыўным фармаце. Аргумэнты — oneline, short, full, fuller і format (дзе вы маеце магчымасьць самастойна ўсталяваць патрэбны фармат).

### Абмежаваньне вываду гісторыі ###

Акрамя опцыяў для фарматаваньня вываду, `git log` мае шэраг карысных опцыяў для абмежаваньня вываду, яны дазваляюць адлюстраваць толькі пэўнае падмноства камітаў. Вы ўжо бачылі адну зь іх — гэта опцыя `-2`, якая адлюструе толькі два апошнія каміты. На самой справе, вы можаце пазначыць `-<n>`, дзе `n` — нейкі цэлы лік. На практыцы, вы наўрад ці будзеце часта выкарыстоўваць яе, бо Git прадвызначана прапускае ўвесь свой вывад праз пэйджэр (pager), таму вы бачыце толькі адну старонку вываду.

Аднак опцыі абмежаваньня паводле часу, такія як `--since` і `--until`, вельмі папулярныя. Напрыклад, наступная каманда атрымае сьпіс камітаў зроблены ў апошнія два тыдні:

	$ git log --since=2.weeks

Яна разумее мноства фарматаў — вы можаце пазначыць пэўную дату (2008-01-15) ці адносную (2 years 1 day 3 minutes ago).

Таксама вы маеце магчымасьць фільтраваць сьпіс камітаў па зададзенай умове. Опцыя `--author` задае імя аўтара, а `--grep` дазваляе выводзіць каміты з ключавымі словамі ў паведамленьні. (Зьвярніце ўвагу на тое, што калі вы жадаеце пазначыць абедзьве опцыі, вы мусіце дадаць опцыю `--all-match`.)

Апошняя сапраўды карысная опцыя — гэта шлях. Калі вы пазначаеце імя дырэкторыі ці файла, вы абмяжоўваеце вывад толькі тымі камітамі, якія ўносяць зьмены ў гэтыя файлы. Гэта опцыя заўсёды павінна быць апошняй і папярэджваецца дзьвюма злучкамі (`--`) каб разьдзяліць шлях і астатнія парамэтры.

У Табліцы 2-3 прыведзены сьпіс часта ўжываных опцыяў.

	Опцыя	Апісаньне
	-(n)	Адлюстраваць толькі апошнія n камітаў
	--since, --after	Абмежаваць камітамі створанымі пасьля пазначанай даты.
	--until, --before	Абмежаваць камітамі створанымі да пазначанай даты.
	--author	Адлюстраваць каміты, у якіх аўтар адпавядае пазначанаму радку.
	--committer	Адлюстраваць каміты, у якіх камітэр адпавядае пазначанаму радку.

Напрыклад, калі вы жадаеце ўбачыць каміты, якія мадыфікавалі тэставыя файлы, былі зроблены Джуніанам Хаманам (Junio Hamano), не зьяўляюцца камітамі аб’яднаньня і зроблены ў кастрычніку 2008, то вы мусіце выканаць наступны загад:

	$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
	   --before="2008-11-01" --no-merges -- t/
	5610e3b - Fix testcase failure when extended attribute
	acd3b9e - Enhance hold_lock_file_for_{update,append}()
	f563754 - demonstrate breakage of detached checkout wi
	d1a43f2 - reset --hard/read-tree --reset -u: remove un
	51a94af - Fix "checkout --track -b newbranch" on detac
	b0ad11e - pull: allow "git pull origin $something:$cur

З каля 20 000 камітаў у гісторыі Git, гэтая каманда адлюстравала толькі шэсьць адпаведных зададзеным крытэрам.

### Візуалізацыя гісторыі ў графічным інтэрфэйсе ###

Калі вам больш падабаюцца прылады з графічным інтэрфэйсам, і вы б хацелі праглядаць у іх гісторыю Git, то можна скарыстацца Tcl/Tk праграмай `gitk`, якая распаўсюджваецца разам з Git. Gitk — гэта базавы інструмэнт для візуалізацыі `git log`, ён дазваляе ўжываць амаль усе фільтраваныя опцыі, якія падтрымлівае `git log`. Пасьля таго, як вы надрукуеце `gitk` у вашым загадным радку ў дырэкторыі праекту, вы ўбачыце прыкладна наступны малюнак:

Insert 18333fig0202.png
Малюнак 2-2. Адлюстраваньне гісторыі з дапамогай gitk.

Вы бачыце гісторыю камітаў у верхняй палове вакна ўздоўж графа паходжаньня. У ніжняй палове знаходзіцца праглядальнік зьменаў унесеных кожным вылучаным камітам.

## Скасаваньне зьменаў ##

У любы момант у вас можа ўзьнікнуць неабходнасьць што-небудзь адмяніць. Зараз мы распавядзём пра некалькі базавых інструмэнтаў для скасаваньня зробленых вамі зьменаў. Будзьце пільнымі, не заўсёды магчыма аднавіць скасаваныя зьмены. Гэта адно зь нешматлікіх месцаў у Git, дзе вы можаце згубіць зробленую вамі працу.

### Зьмена апошняга каміту ###

Адзін з найбольш тыповых выпадкаў зьмены апошняга каміту, калі вы занадта рана зрабілі каміт, ці забылі дадаць нейкія файлы, ці наблыталі нешта ў камэнтары. Калі вы хочаце перарабіць каміт, то запусьціце каманду камітаваньня разам з опцыяй `--amend`:

	$ git commit --amend

Яна дадае падрыхтаваныя вамі файлы ў каміт. Калі вы нічога не зьмянілі пасьля апошняга каміту (напрыклад, вы запусьцілі гэтую каманду адразу пасьля стварэньня каміту), то „здымак“ праекту, які захоўвае каміт, застанецца такім самым, адзінае што вы зьменіце — гэта камэнтар.

Зьявіцца той самы рэдактар паведамленьняў камітаў, але разам з старым паведамленьнем. Вы можаце адрэдагаваць гэты тэкст як і заўсёды, і ён будзе захаваны замест старога.

Напрыклад, калі пасьля каміту вы ўзгадалі, што забылі падрыхтаваць зьмены ў адным з файлаў, але неабходна іх туды дадаць, то вам патрэбна зрабіць наступнае:

	$ git commit -m 'initial commit'
	$ git add forgotten_file
	$ git commit --amend

Усе гэтыя тры каманды ў выніку створаць адзіны каміт — каміт апошняй каманды заменіць каміт першай.

### Выдаленьне файла з прасторы рыхтаваньня ###

У наступных двух разьдзелах мы прадэманструем як кантраляваць стан файлаў у прасторы рыхтаваньня і працоўнай дырэкторыі. Прыемным зьяўляецца тое, што каманда для вываду стану нагадвае, як скасаваць зьмены. Для прыкладу, давайце ўявім, што вы адрэдагавалі два файлы й жадаеце закаміціць іх асобна адзін ад аднаго, але выпадкова ўжо выканалі `git add *` і падрыхтавалі абодва файлы. Як выдаліць адзін з файлаў з прасторы рыхтаваньня? Каманда `git status` нагадае вам:

	$ git add .
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       modified:   README.txt
	#       modified:   benchmarks.rb
	#

Пад надпісам „Changes to be committed“ напісана „use `git reset HEAD <file>...` to unstage“, што значыць „выкарыстоўвай `git reset HEAD <file>...` для адмены рыхтаваньня“. Давайце рушым усьлед радзе і разрыхтуем файл `benchmarks.rb`:

	$ git reset HEAD benchmarks.rb
	benchmarks.rb: locally modified
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       modified:   README.txt
	#
	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#   (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#       modified:   benchmarks.rb
	#

Гэта каманда крыху дзіўная, але яна працуе. Цяпер файл `benchmarks.rb` мадыфікаваны й не падрыхтаваны.

### Скасаваньне зьменаў файла ###

А што, калі вы вырашылі, што не жадаеце пакідаць зьмены зробленыя ў файле `benchmarks.rb`? Як проста скасаваць іх — вярнуць усё да стану апошняга каміту (ці стану пасьля кланаваньня альбо любога іншага дзеяньня, зь якім у працоўнай дырэкторыі зьявіўся гэты файл)? На шчасьце `git status` зноў падкажа нам, як гэта зрабіць. У вывадзе апошняга прыкладу, непадрыхтаваная прастора выглядала так:

	# Changed but not updated:
	#   (use "git add <file>..." to update what will be committed)
	#   (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#       modified:   benchmarks.rb
	#

Тут даволі відавочна сказана, як скасаваць зробленыя вамі зьмены (ва ўсялякім разе, гэта падтрымліваюць вэрсіі Git 1.6.1 і старэйшыя; калі ў вас старая вэрсія, то мы настойліва раім абнавіць праграму). Давайце зробім тое што прапанавана:

	$ git checkout -- benchmarks.rb
	$ git status
	# On branch master
	# Changes to be committed:
	#   (use "git reset HEAD <file>..." to unstage)
	#
	#       modified:   README.txt
	#

Вы можаце бачыць, што зьмены былі адменены. Магчыма, вы таксама заўважылі, што гэтая каманда небясьпечная: любыя зробленыя вамі зьмены ў гэтым файле зьніклі — вы проста скапіявалі паверх яго іншы файл. Ніколі не выкарыстоўвайце гэту каманду, калі абсалютна ня ўпэўнены, што вам не патрэбны гэты файл. Калі вам проста неабходна, каб ён ня блытаўся пад нагамі, то ў наступнай главе мы разглядзім, як вырашыць гэта з дапамогай затойваньня (stashing) і разгалінаваньня; гэтыя спосабы звычайна больш прыдатныя.

Запомніце, усё, што было зафіксавана, амаль заўсёды можа быць адноўлена. Нават каміты, якія былі ў выдаленых галінах, ці перазапісаныя з опцыяй `--amend` (пра аднаўленьне зьвестак глядзіце *Главу 9*). Аднак, усё што не трапляла ў каміты, хутчэй за ўсё, вы ўжо ніколі ня ўбачыце.

## Праца з аддаленымі сховішчамі ##

Каб мець магчымасьць сумеснай працы над якім-небудзь праектам, вам неабходна ведаць, як кіраваць аддаленымі сховішчамі. Аддаленыя сховішчы — гэта вэрсіі вашага праекту, якія захоўваюцца ў Інтэрнэце ці яшчэ дзе-небудзь у сеціве. Іх можа быць некалькі, кожнае зь якіх даступна вам ці толькі для чытаньня, ці для чытаньня й запісу. Супрацоўніцтва зь іншымі праграмістамі ўключае ў сябе кіраваньне гэтымі аддаленымі сховішчамі, даданьне й сьцягваньне зьвестак зь іх, калі вы жадаеце падзяліцца вынікамі працы.
Кіраваньне аддаленымі сховішчамі патрабуе наступных ведаў: дадаваць аддаленыя сховішчы, выдаляць тыя зь іх, якія больш не зьяўляюцца дзейнымі, кіраваць рознымі аддаленымі галінамі і вызначаць іх як адсочаныя ці не, і іншае. Гэты разьдзел зьмяшчае апісаньне гэтых „аддаленых“ навыкаў.

### Адлюстраваньне вашых аддаленых сховішчаў ###

Каб убачыць, якія аддаленыя сэрверы вы ўжо наладзілі, вы можаце выканаць каманду `git remote`. Яна выводзіць сьпіс кароткіх імён кожнай пазначанай вамі спасылкі да аддаленага сховішча. Калі вы скланавалі ваша сховішча, то, як мінімум, пабачыце *origin* — гэта прадвызначанае імя Git дае сэрверу, зь якога праект быў скланаваны:

	$ git clone git://github.com/schacon/ticgit.git
	Initialized empty Git repository in /private/tmp/ticgit/.git/
	remote: Counting objects: 595, done.
	remote: Compressing objects: 100% (269/269), done.
	remote: Total 595 (delta 255), reused 589 (delta 253)
	Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.
	Resolving deltas: 100% (255/255), done.
	$ cd ticgit
	$ git remote
	origin

Яшчэ вы можаце дадаць опцыю `-v`, якая, акрамя кароткага імя, адлюстроўвае URL, зь якога Git запампаваў сховішча:

	$ git remote -v
	origin	git://github.com/schacon/ticgit.git

Калі вы маеце больш за адну аддаленую спасылку, то гэтая каманда адлюструе іх усіх. Напрыклад, маё сховішча Grit выглядае прыкладна так:

	$ cd grit
	$ git remote -v
	bakkdoor  git://github.com/bakkdoor/grit.git
	cho45     git://github.com/cho45/grit.git
	defunkt   git://github.com/defunkt/grit.git
	koke      git://github.com/koke/grit.git
	origin    git@github.com:mojombo/grit.git

Гэта значыць, што сьцягваць укладаньні ад розных людзей вельмі проста. Але заўважце, што толькі першапачатковая (origin) спасылка — SSH URL, таму абнаўляць зьвесткі вы можаце толькі ў адным аддаленым сховішчы (як гэта рабіць, вы пабачыце ў *Главе 4*).

### Даданьне аддаленага сховішча ###

У папярэдніх разьдзелах, я ўжо прадэманстраваў некаторыя прыклады дадаваньня аддаленых сховішч, і зараз я растлумачу гэта больш дакладна. Каб дадаць новае аддаленае сховішча са скарочанай назвай, да якой будзе прасьцей зьвяртацца, выканайце `git remote add [shortname] [url]`:

	$ git remote
	origin
	$ git remote add pb git://github.com/paulboone/ticgit.git
	$ git remote -v
	origin	git://github.com/schacon/ticgit.git
	pb	git://github.com/paulboone/ticgit.git

Цяпер вы маеце магчымасьць выкарыстоўваць назву `pb` у загадным радку замест поўнага URL. Напрыклад, калі вы жадаеце сьцягнуць усе абнаўленьні, якія зрабіў Пол (Paul), і якіх вы яшчэ ня маеце ў вашым сховішчы, то запусьціце наступную каманду:

	$ git fetch pb
	remote: Counting objects: 58, done.
	remote: Compressing objects: 100% (41/41), done.
	remote: Total 44 (delta 24), reused 1 (delta 0)
	Unpacking objects: 100% (44/44), done.
	From git://github.com/paulboone/ticgit
	 * [new branch]      master     -> pb/master
	 * [new branch]      ticgit     -> pb/ticgit

Галіна master са сховішча Пола дасяжна лякальна як `pb/master`. Вы можаце зьліць яе ў адну з вашых галін, ці зрабіць зь яе асобную лякальную галіну, калі вы жадаеце „пакапацца“ ў ёй.

### Сьцягваньне і ўжываньне зьменаў з аддаленага сховішча ###

Як вы толькі што ўбачылі, каб атрымаць зьвесткі з аддаленага сховішча, трэба выканаць:

	$ git fetch [remote-name]

Дадзеная каманда выходзіць на пазначаны аддалены праект і сьцягвае ўсе зьвесткі, якія вы яшчэ ня маеце ў сваім сховішчы. Пасьля гэтага ў вас зьявяцца спасылкі на ўсе галіны аддаленага сховішча, якія вы можаце зьліваць з вашымі галінамі і праглядаць у любы момант. (Больш падрабязна мы распавядзем пра галіны і як іх выкарыстоўваць у *Главе 3*).

Калі вы скланавалі сховішча, то была аўтаматычна дададзена спасылка з назвай *origin*. Такім чынам `git fetch origin` сьцягвае ўсе новыя зьмены, якія былі захаваны на тым сэрверы ад часу кланаваньня (ці апошняга сьцягваньня). Важна разумець, што каманда `fetch` сьцягвае зьвесткі ў ваша лякальнае сховішча, але не зьлівае іх з вашымі галінамі і не мадыфікуе тое, з чым вы на дадзены момант працуеце. Вы мусіце самастойна аб’яднаць гэтыя дадзеныя з вашай працай, калі падрыхтуецеся.

Калі ў вас ёсьць галіна, якая сочыць за аддаленай галіной (гл. наступны разьдзел і *Главу 3*), то вы можаце выкарыстаць каманду `git pull` для аўтаматычнага сьцягваньня й зьліцьця зьвестак з аддаленай галіны ў бягучую. Гэта магчыма будзе больш проста й зручна для вас. Прадвызначана, каманда `git clone` аўтаматычна ўсталёўвае вашу лякальную галіну master для адсочваньня аддаленай master-галіны на сэрверы зь якога вы скланавалі сховішча (мяркуючы, што аддаленая master-галіна існуе). Запуск `git pull`, як правіла, сьцягвае зьвесткі з сэрвера, зь якога вы скланавалі праект, і аўтаматычна спрабуе зьліць іх з кодам, над якім вы цяпер працуеце.

### Адсыланьне зьменаў у аддаленае сховішча ###

Калі ваш праект дасягае стадыі, што ўзьнікае жаданьне падзяліцца напрацоўкамі, вы мусіце адправіць вашыя зьвесткі ў галоўнае сховішча. Каманда для гэтага вельмі простая: `git push [remote-name] [branch-name]`. Калі вы жадаеце дадаць вашую master-галіну на сэрвер `origin` (скажу яшчэ раз, што кланаваньне ўсталёўвае гэткія назвы аўтаматычна), то вы можаце выканаць наступнае:

	$ git push origin master

Гэта каманда будзе працаваць толькі тады, калі вы скланавалі сваё сховішча з сэрвера, у якім вы маеце правы на запіс і між тым больш ніхто не пасьпеў выканаць каманду push. Калі вы і нехта яшчэ зрабілі клон ў адзін той жа час, і вы вырашылі загрузіць вашыя абнаўленьні пазьней за іх, то ваш запыт будзе адхілены. Вам будзе неабходна спачатку сьцягнуць іхныя зьвесткі, аб’яднаць з вашымі, і толькі пасьля гэтага вы зможаце выканаць `push`. Для больш падрабязнай інфармацыі, як адпраўляць зьвесткі ў аддаленае сховішча, зьвяртайцеся да *Главы 3*.

### Вывучаем аддаленае сховішча ###

Калі вы жадаеце ўбачыць больш інфармацыі пра пэўнае аддаленае сховішча, то вы можаце скарыстацца камандай `git remote show [remote-name]`. Калі вы запусьціце яе са скарочанай назвай сховішча, напрыклад origin, то пабачыце нешта накшталт наступнага:

	$ git remote show origin
	* remote origin
	  URL: git://github.com/schacon/ticgit.git
	  Remote branch merged with 'git pull' while on branch master
	    master
	  Tracked remote branches
	    master
	    ticgit

Тут адлюстраваны URL аддаленага сховішча і інфармацыя пра адсочаныя галіны. Падказка тлумачыць што адбудзецца, калі вы выканаеце `git pull`. А адбудзецца аўтаматычнае зьліцьцё аддаленай master-галіны з лякальнай. Да таго ж, тут можна ўбачыць сьпіс ўсіх аддаленых спасылак, зь якіх прымаліся абнаўленьні.

Гэта быў даволі просты прыклад. Калі вы выкарыстоўваеце Git больш інтэнсіўна, то, хутчэй за ўсё, вы ўбачыць значна больш інфармацыі:

	$ git remote show origin
	* remote origin
	  URL: git@github.com:defunkt/github.git
	  Remote branch merged with 'git pull' while on branch issues
	    issues
	  Remote branch merged with 'git pull' while on branch master
	    master
	  New remote branches (next fetch will store in remotes/origin)
	    caching
	  Stale tracking branches (use 'git remote prune')
	    libwalker
	    walker2
	  Tracked remote branches
	    acl
	    apiv2
	    dashboard2
	    issues
	    master
	    postgres
	  Local branch pushed with 'git push'
	    master:master

Гэтая каманда паказвае, якая менавіта галіна будзе адпраўлена на сэрвер, калі вы запускаеце `git push`. Таксама яна адлюстроўвае тыя галіны сэрвера, якіх у вас яшчэ няма, якія вы маеце, але былі выдалены з сэрвера, і сьпіс галін, у якія будуць зьліты зьвесткі, калі вы выканаеце `git pull`.

### Выдаленьне й перайменаваньне спасылак на сховішчы ###

Калі вы жадаеце перайменаваць спасылку, то ў новых вэрсіях Git вы можаце выканаць `git remote rename`. Напрыклад, каб зьмяніць `pb` на `paul`, неабходна запусьціць наступную каманду:

	$ git remote rename pb paul
	$ git remote
	origin
	paul

Варта адзначыць, што гэта таксама зьмяняе назву галін аддаленага сховішча. Калі раней трэба было выкарыстоўваць `pb/master`, то зараз — `paul/master`.

Калі вы хочаце выдаліць спасылку (магчыма вы зьмянілі сэрвер, ці больш не выкарыстоўваеце пэўнае люстэрка, ці хтосьці з удзельнікаў праекту перастаў ім займацца), то вы можаце скарыстацца камандай `git remote rm`:

	$ git remote rm paul
	$ git remote
	origin

## Тэґаваньне ##

Як і ў большасьці СКВ, Git мае магчымасьць адзначаць важныя моманты гісторыі праекту. Часьцей за ўсё іх выкарыстоўваюць для паметкі рэлізаў (`v1.0` і г.д.). У дадзеным разьдзеле вы даведаецеся як праглядзець сьпіс даступных тэґаў, як стварыць новыя і якія тыпы тэґаў існуюць.

### Прагляд вашых тэґаў ###

Праглядзець сьпіс даступных тэґаў вельмі лёгка. Проста надрукуйце `git tag`:

	$ git tag
	v0.1
	v1.3

Гэтая каманда адлюструе тэґі ў альфабэтным парадку. Парадак у якім тэґі ствараліся ня мае значэньня.

Таксама можна шукаць тэґі з дапамогай шаблёнаў. Напрыклад, сховішча зыходных кодаў Git утрымлівае больш за 240 тэґаў. Калі вас цікавіць толькі вэрсія 1.4.2, вы можаце выканаць:

	$ git tag -l 'v1.4.2.*'
	v1.4.2.1
	v1.4.2.2
	v1.4.2.3
	v1.4.2.4

### Стварэньне тэґаў ###

Git выкарыстоўвае два асноўныя тыпы тэґаў: легкаважны і анатаваны. Легкаважны тэґ вельмі падобны на галіну, якую нельга зьмяняць, — гэта проста паказальнік на пэўны каміт. У адрозьненьні ад яго, анатаваныя тэґі загружаюцца ў базу зьвестак Git’а як паўнавартасныя аб’екты. Яны маюць кантрольную суму, імя стваральніка і яго пошту, дату, паведамленьне, і могуць быць падпісаны й правераны з дапамогай GNU Privacy Guard (GPG). Рэкамэндуецца захоўваць усю гэтую інфармацыю ў створаных тэґах, але калі вам патрэбны часовы тэґ, то лепш скарыстацца легкаважнымі тэґамі.

### Анатаваныя тэґі ###

Стварыць анатаваны тэґ у Git не складана. Самы просты шлях — пазначыць `-a` у камандзе `tag`:

	$ git tag -a v1.4 -m 'my version 1.4'
	$ git tag
	v0.1
	v1.3
	v1.4

Опцыя `-m` адказвае за паведамленьне, якое будзе захавана разам з тэґам. Калі вы не пазначылі паведамленьне ў загадным радку, то Git адчыніць рэдактар, у якім вы можаце яго надрукаваць.

Вы можаце пабачыць зьвесткі тэґа разам са зьвесткамі пра каміт, на які тэґ спасылаецца, выкарыстаўшы каманду `git show`:

	$ git show v1.4
	tag v1.4
	Tagger: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Feb 9 14:45:11 2009 -0800

	my version 1.4
	commit 15027957951b64cf874c3557a0f3547bd83b3ff6
	Merge: 4a447f7... a6b4c97...
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sun Feb 8 19:02:46 2009 -0800

	    Merge branch 'experiment'

Тут мы бачым зьвесткі пра стваральніка тэґа, зьвесткі адпаведнага каміту і паведамленьне над імі.

### Падпісаньне тэґаў ###

Вы можаце падпісаць вашыя тэґі пры дапамозе GPG (пры ўмове, што вы маеце прыватны ключ). Усё што вы мусіце зрабіць — замяніць опцыю `-a` на `-s`:

	$ git tag -s v1.5 -m 'my signed 1.5 tag'
	You need a passphrase to unlock the secret key for
	user: "Scott Chacon <schacon@gee-mail.com>"
	1024-bit DSA key, ID F721C45A, created 2009-02-09

Калі вы запусьціце `git show` для гэтага тэґа, вы ўбачыце прымацаваны подпіс (signature):

	$ git show v1.5
	tag v1.5
	Tagger: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Feb 9 15:22:20 2009 -0800

	my signed 1.5 tag
	-----BEGIN PGP SIGNATURE-----
	Version: GnuPG v1.4.8 (Darwin)

	iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
	Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
	=WryJ
	-----END PGP SIGNATURE-----
	commit 15027957951b64cf874c3557a0f3547bd83b3ff6
	Merge: 4a447f7... a6b4c97...
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sun Feb 8 19:02:46 2009 -0800

	    Merge branch 'experiment'

Крыху пазьней, вы даведаецеся, як пацьвярджаць подпісы тэґаў.

### Легкаважныя тэґі ###

Другі шлях пазначыць каміт — гэта легкаважны тэґ. Гэта звычайная кантрольная сума каміту запісаная ў файл, больш ніякай іншай інфармацыі. Каб стварыць легкаважны тэґ, ня трэба ўжываць опцыяў `-a`, `-s` і `-m`:

	$ git tag v1.4-lw
	$ git tag
	v0.1
	v1.3
	v1.4
	v1.4-lw
	v1.5

На гэты раз, калі вы запусьціце `git show`, вы ня ўбачыце дадатковай інфармацыі пра тэґ. Каманда адлюструе толькі каміт:

	$ git show v1.4-lw
	commit 15027957951b64cf874c3557a0f3547bd83b3ff6
	Merge: 4a447f7... a6b4c97...
	Author: Scott Chacon <schacon@gee-mail.com>
	Date:   Sun Feb 8 19:02:46 2009 -0800

	    Merge branch 'experiment'

### Пацьверджаньне тэґаў ###

Каб пацьвердзіць подпіс тэґа, трэба скарыстацца `git tag -v [tag-name]`. Гэта каманда з дапамогай GPG правярае подпіс. Каб гэта зрабіць правільна, вам патрэбны адкрыты ключ аўтара подпісу.

	$ git tag -v v1.4.2.1
	object 883653babd8ee7ea23e6a5c392bb739348b1eb61
	type commit
	tag v1.4.2.1
	tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700

	GIT 1.4.2.1

	Minor fixes since 1.4.2, including git-mv and git-http with alternates.
	gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
	gpg: Good signature from "Junio C Hamano <junkio@cox.net>"
	gpg:                 aka "[jpeg image of size 1513]"
	Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A

Калі вы ня маеце адкрытага ключа, то атрымаеце прыкладна наступны вывад:

	gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
	gpg: Can't check signature: public key not found
	error: could not verify the tag 'v1.4.2.1'

### Выстаўленьне тэґа на пэўным каміце ###

Вы можаце ствараць тэґі для камітаў, якія вы ўжо даўно прайшлі. Напрыклад, ваша гісторыя камітаў выглядае наступным чынам:

	$ git log --pretty=oneline
	15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
	a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
	0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
	6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
	0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
	4682c3261057305bdd616e23b64b0857d832627b added a todo file
	166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
	9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
	964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
	8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme

Цяпер уявім, што вы забылі адзначыць тэґам вэрсію `v1.2`, каміт якой называецца „updated rakefile“. Але вы можаце зрабіць гэта й зараз. Каб стварыць тэґ, неабходна пазначыць кантрольную суму (ці яго частку) адпаведнага каміту напрыканцы каманды:

	$ git tag -a v1.2 9fceb02

Можна паглядзець на адзначаны каміт:

	$ git tag
	v0.1
	v1.2
	v1.3
	v1.4
	v1.4-lw
	v1.5

	$ git show v1.2
	tag v1.2
	Tagger: Scott Chacon <schacon@gee-mail.com>
	Date:   Mon Feb 9 15:32:16 2009 -0800

	version 1.2
	commit 9fceb02d0ae598e95dc970b74767f19372d61af8
	Author: Magnus Chacon <mchacon@gee-mail.com>
	Date:   Sun Apr 27 20:43:35 2008 -0700

	    updated rakefile
	...

### Агульнадасяжныя тэґі ###

Прадвызначана, каманда `git push` не перасылае тэґі на аддаленыя сэрверы. Вы павінны самастойна адправіць тэґі на агульнадасяжны сэрвер пасьля таго, як іх захаваеце. Гэта робіцца такім жа чынам, як і перасылка галін — трэба выканаць `git push origin [tagname]`.

	$ git push origin v1.5
	Counting objects: 50, done.
	Compressing objects: 100% (38/38), done.
	Writing objects: 100% (44/44), 4.56 KiB, done.
	Total 44 (delta 18), reused 8 (delta 1)
	To git@github.com:schacon/simplegit.git
	* [new tag]         v1.5 -> v1.5

Калі ў вас шмат тэґаў, якія вы хочаце адаслаць разам, то скарыстайце опцыю `--tags`. Яна перашле на аддалены сэрвер ўсе вашыя тэґі, якіх там яшчэ няма.

	$ git push origin --tags
	Counting objects: 50, done.
	Compressing objects: 100% (38/38), done.
	Writing objects: 100% (44/44), 4.56 KiB, done.
	Total 44 (delta 18), reused 8 (delta 1)
	To git@github.com:schacon/simplegit.git
	 * [new tag]         v0.1 -> v0.1
	 * [new tag]         v1.2 -> v1.2
	 * [new tag]         v1.4 -> v1.4
	 * [new tag]         v1.4-lw -> v1.4-lw
	 * [new tag]         v1.5 -> v1.5

Цяпер, калі нехта склануе ваша сховішча, то атрымае ўсе вашыя тэґі.

## Парады і хітрыкі ##

Перад тым як скончыць, распавяду пра некалькі маленькіх парадаў і хітрыкаў, якія зробяць выкарыстаньне Git больш простым і зручным. Шмат хто карыстаецца Git без гэтых магчымасьцяў, і далей у гэтай кнізе мы ня будзем спасылацца на іх ці лічыць, што вы іх ведаеце. Але ўсядно вам варта іх ведаць.

### Самадавяршэньне ###

Калі вы карыстаецеся абалонкай Bash, то вы маеце магчымасьць уключыць скрыпт самадавяршэньня для Git. Спампуйце зыходны код Git і паглядзіце ў дырэкторыю `contrib/completion`. Там вы павінны ўбачыць файл з назвай `git-completion.bash`. Скапіюйце гэты файл у вашу хатнюю тэчку і дадайце ў ваш файл `.bashrc` наступны радок:

	source ~/.git-completion.bash

Калі вы жадаеце ўсталяваць самадавяршэньне Git для ўсіх карыстальнікаў, то скапіюйце гэты скрыпт у тэчку `/opt/local/etc/bash_completion.d` на Mac-сыстэмах, і `/etc/bash_completion.d/` на Linux. Гэта дырэкторыя з скрыптамі, якія Bash аўтаматычна чытае для падтрымкі самадавяршэньня.

Калі вы карыстаецеся Git Bash на Windows, які быў усталяваны разам з msysGit, то самадавяршэньне там працуе прадвызначана.

Націсьніце на клявішу Tab, пасьля таго як вы напісалі частку каманды Git, і вам прапануюць некалькі верагодных варыянтаў камандаў:

	$ git co<tab><tab>
	commit config

У дадзеным выпадку, пасьля каманды `git co` падвоены націск на Tab надрукуе вам дзьве магчымыя каманды `commit` і `config`. Калі вы дададзіце `m<tab>`, то будзе аўтаматычна давершана каманда `git commit`.

Самадавяршэньне таксама працуе для опцыяў, што можа быць яшчэ больш карысным. Напрыклад, калі вы запускаеце `git log` але дакладна ня памятаеце назву патрэбнай опцыі, то можна пачаць друкаваць яе, і Tab вам прапануе магчымыя варыянты:

	$ git log --s<tab>
	--shortstat  --since=  --src-prefix=  --stat   --summary

Гэты вельмі прыемны хітрык можа вам захаваць крыху часу й неабходнасьць чытаць дакумэнтацыю.

### Псэўданімы Git ###

Git не зразумее часткова надрукаваную каманду. Калі вы ня хочаце пісаць яе цалкам, то можна наладзіць схему скаротаў камандаў з дапамогай `git config`. Тут мы прадэманструем некалькі прыкладаў, як вы можаце гэта зрабіць:

	$ git config --global alias.co checkout
	$ git config --global alias.br branch
	$ git config --global alias.ci commit
	$ git config --global alias.st status

Прыведзены прыклад кажа, што цяпер замест паўнавартаснай каманды `git commit`, напрыклад, можна проста надрукаваць `git ci`. На працягу карыстаньня Git’ам, у вас верагодна зьявяцца найбольш часта ўжываныя загады. У гэтым выпадку без сумневаў стварайце новы псэўданім.

Гэта тэхніка таксама вельмі карысная ў стварэньні камандаў, якія б вы хацелі мець. Напрыклад, каб выправіць нязручнасьць пры выдаленьні файла з прасторы рыхтаваньня, вы можаце дадаць наступны псэўданім:

	$ git config --global alias.unstage 'reset HEAD --'

Цяпер наступныя дзьве каманды эквівалентныя:

	$ git unstage fileA
	$ git reset HEAD fileA

Так выглядае больш зразумела. Яшчэ вельмі часта ствараюць каманду `last`:

	$ git config --global alias.last 'log -1 HEAD'

Так можна хутка атрымаць і прагледзець апошні каміт:

	$ git last
	commit 66938dae3329c7aebe598c2246a8e6af90d04646
	Author: Josh Goebel <dreamer3@example.com>
	Date:   Tue Aug 26 19:48:51 2008 +0800

	    test for current head

	    Signed-off-by: Scott Chacon <schacon@example.com>

Як вы можаце бачыць, Git проста замяняе новыя каманды на тое, што вы пазначылі ў наладках. Аднак, магчыма вы жадаеце запускаць зьнешнюю каманду, замест падкаманды Git. У такім выпадку, неабходна пачаць пісаць загад з клічніка `!`. Гэта можа спатрэбіцца, калі вы пішаце свае ўласныя інструмэнты для працы са сховішчам. Як прыклад, прадэманструем псэўданім `git visual` для запуску `gitk`.

	$ git config --global alias.visual "!gitk"

## Вынікі ##

Цяпер вы можаце рабіць усе базавыя лякальныя апэрацыі Git: ствараць і кланаваць сховішчы, рабіць зьмены, рыхтаваць і фіксаваць іх, праглядаць гісторыю зьменаў. Далей, мы апішам самую забойную адметнасьць Git — яго мадэль галінаваньня.
